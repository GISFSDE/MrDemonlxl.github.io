<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM 与上层技术 - 魑魅先生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="魑魅先生"><meta name="msapplication-TileImage" content="https://gitee.com/mychimei/picture/raw/master/透明头像.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="魑魅先生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="JVM 与上层技术"><meta property="og:type" content="blog"><meta property="og:title" content="魑魅先生"><meta property="og:url" content="https://mrdemonlxl.github.io/"><meta property="og:site_name" content="魑魅先生"><meta property="og:description" content="JVM 与上层技术"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/mychimei/picture/raw/master/微信图片_20210131173244.jpg"><meta property="article:published_time" content="2021-11-10T14:10:43.000Z"><meta property="article:modified_time" content="2021-11-26T06:02:45.000Z"><meta property="article:author" content="mrdemonlxl"><meta property="article:tag" content="底层学习"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/mychimei/picture/raw/master/微信图片_20210131173244.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://mrdemonlxl.github.io/2021/11/10/Draft/2021/JVM%20%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/"},"headline":"魑魅先生","image":["https://gitee.com/mychimei/picture/raw/master/39go6v.jpg"],"datePublished":"2021-11-10T14:10:43.000Z","dateModified":"2021-11-26T06:02:45.000Z","author":{"@type":"Person","name":"魑魅先生"},"description":"JVM 与上层技术"}</script><link rel="canonical" href="http://mrdemonlxl.github.io/2021/11/10/Draft/2021/JVM%20%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/"><link rel="icon" href="https://gitee.com/mychimei/picture/raw/master/透明头像.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://gitee.com/mychimei/picture/raw/master/彩色logo.png" alt="魑魅先生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/music">音乐</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://gitee.com/mychimei/picture/raw/master/39go6v.jpg" alt="JVM 与上层技术"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2021-11-10  <a class="commentCountImg" href="/2021/11/10/Draft/2021/JVM%20%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/#comment-container"><span class="display-none-class">486d51bdeafd99dbf0aa6c0067a949d5</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="486d51bdeafd99dbf0aa6c0067a949d5">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>19.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div><div class="pin-icon"><i class="fas fa-thumbtack"></i></div></div><h1 class="title is-3 is-size-4-mobile">JVM 与上层技术</h1><div class="content"><blockquote>
<p>JVM 与上层技术</p>
</blockquote>
<a id="more"></a>
<blockquote>
<h1 id="新学四问"><a href="#新学四问" class="headerlink" title="新学四问"></a>新学四问</h1><p><strong>WHY【与前代优化了什么，弥补了什么空白】：</strong>了解底层，优化，面试，解决底层BUG<br><strong>WHAT【框架，思维导图，主题框架】：</strong>结构，<br><strong>HOW【如何记忆，学习资源】</strong>：学习资源：尚硅谷JVM，ANKI记忆<br><strong>LEVEL【不是每个都学精】：</strong>了解</p>
</blockquote>
<h1 id="进度：上篇-第八章【72】"><a href="#进度：上篇-第八章【72】" class="headerlink" title="进度：上篇 第八章【72】"></a>进度：上篇 第八章【72】</h1><h1 id="上篇：内存与垃圾回收"><a href="#上篇：内存与垃圾回收" class="headerlink" title="上篇：内存与垃圾回收"></a>上篇：内存与垃圾回收</h1><h1 id="一、JVM与JAVA体系结构"><a href="#一、JVM与JAVA体系结构" class="headerlink" title="一、JVM与JAVA体系结构"></a>一、JVM与JAVA体系结构</h1><h2 id="1-JAVA与JVM"><a href="#1-JAVA与JVM" class="headerlink" title="1.JAVA与JVM"></a>1.JAVA与JVM</h2><h3 id="Java大事件"><a href="#Java大事件" class="headerlink" title="Java大事件"></a>Java大事件</h3><ul>
<li>1990年，在sun公司中，由Patrick naughton、mikesheridan以及james Gosling领导的小组Green Team，开发出新的程序语言，命名为OAK，后期更名为Java</li>
<li>1995年，sun正式发布Java和hotJAVA产品，Java首次公开亮相。</li>
<li>1996年1月23日sun Microsystems发布了JDK1.0.</li>
<li>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java默认的虚拟机。</li>
<li>2002年，JDK 1.4发布，古老的classic虚拟机退出历史舞台。</li>
<li>2003年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li>
<li>2004年，JDK1.5发布，同时JDK1.5改名为JavaSE5.0.</li>
<li>2006年，JDK 6发布，同年Java开源并建立了openJDK，顺理成章，Hotspot虚拟机成为了OpenJDK中默认的虚拟机。</li>
<li>2007年，Java平台迎来了新伙伴Clojure。</li>
<li>2008年，Oracle收购了BEA，得到了JRockit虚拟机。</li>
<li>2009年，Twitter宣布将后台大部分程序从ruby迁移到Scala，这是Java平台的有一次大规模应用。</li>
<li>2010年，Oracle收购了sun，获得Java商标和最具价值的hotspot虚拟机。此时Oracle拥有市场占用率最高的两款虚拟机hotspot和JRockit，并且计划未来进行整合：HotRockit。</li>
<li>2011年，JDK7发布，在JDK１.7ｕ4中，正式启用了新的垃圾回收器G1.</li>
<li>2017年，JDK9发布，将G1设置为默认GC，替代CMS。</li>
<li>2017同年，IBM的J9开源，形成了现在的open J9社区。</li>
<li>2018年，Android的Java侵权案判决，Google公司赔偿Oracle总计88亿美元。</li>
<li>2018同年，Oracle宣布JavaEE成为历史名词，JDBC、JMS、Servlet赠与Eclipse基金会。</li>
<li>2018同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可。</li>
<li>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC。</li>
<li>在JDK11之前，OracleJDK还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，openJDK和OracleJDK代码实质上已经达到完全一致的程度。</li>
</ul>
<h3 id="JVM介绍"><a href="#JVM介绍" class="headerlink" title="JVM介绍"></a>JVM介绍</h3><p>​        所谓虚拟机(Virtual Machine)，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。大名鼎鼎的Visual Box,VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<p>​        Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制,其运行的Java字节码也未必由Java语言编译而成。JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine) ,因为所有的Java程序都运行在Java虚拟机内部。</p>
<p><strong>作用：</strong>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规汜甲都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。<br><strong>特点：</strong>一次编译，到处运行；自动内存管理；自动垃圾回收功能</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台" style="zoom: 50%;" /></p>
<p><strong>位置：</strong></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt="第01章_JVM所处位置" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211111191323311.png" alt="image-20211111191323311" style="zoom: 80%;" /></p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD.jpg" alt="第02章_JVM架构-中" style="zoom:50%;" /><br><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg" alt="第02章_JVM架构-英" style="zoom:50%;" /></p>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p>​        <img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211111192234413.png" alt="image-20211111192234413"></p>
<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是基于寄存器的指令集架构。</p>
<p><strong>区别:</strong></p>
<p><strong>·基于栈式架构的特点</strong><br>设计和实现更简单，适用于资源受限的系统;<br>避开了寄存器的分配难题:使用零地址指令方式分配。<br>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。<br>不需要硬件支持，可移植性更好，更好实现跨平台</p>
<p><strong>基于寄存器架构的特点</strong><br>典型的应用是x86的二进制指令集:比如传统的pc以及Android的Davlik虚拟机。<br>指令集架构则完全依赖硬件,可移植性差<br>性能优秀和执行更高效;<br>花费更少的指令去完成一项操作。<br>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</p>
<p><strong>总结:</strong><br>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPu架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。<br>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确的来说HotSpotVM的宿主环境已经不局限于嵌入式平台了)，那么为什么不将<br>架构更换为基于寄存器的架构呢?<br>栈:<br>跨平台性、指令集小、指令多;执行性能比寄存器差</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Java虚拟机的启动是通过<strong>引导类加载器(bootstrap class loader)</strong>创建一个<strong>初始类</strong>(initial class)来完成的，这个类是由虚拟机的具体实现指定的</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>一个运行中的Java虚拟机有着一个清晰的任务:执行Java程序。<br>程序开始执行时他才运行，程序结束时他就停止。<br>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做<strong>Java虚拟机的进程</strong>。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>有如下的几种情况:。程序正常执行结束<br>·程序在执行过程中遇到了异常或错误而异常终止·由于操作系统出现错误而导致Java虚拟机进程终止<br>·某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。<br>·除此之外，JNI ( Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</p>
<h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="SUN-Classic-VM"><a href="#SUN-Classic-VM" class="headerlink" title="SUN Classic VM"></a>SUN Classic VM</h3><p>·早在1996年Java1.0版本的时候，sun公司发布了一款名为Sun Classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。<br>·这款虚拟机内部只提供解释器。<br>·如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。<br>·现在hotspot内置了此虚拟机。</p>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>·为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<br>Exact Memory Management:准确式内存管理<br>·也可以叫Non-conservative/Accurate Memory Management：虚拟机可以知道内存中某个位置的数据具体是什么类型。<br>具备现代高性能虚拟机的雏形<br>·热点探测<br>·编译器与解释器混合工作模式I<br>只在solaris平台短暂使用，其他平台上还是classic vm<br>·英雄气短，终被Hotspot虚拟机替换</p>
<h3 id="SUN公司的-HotSpot-VM"><a href="#SUN公司的-HotSpot-VM" class="headerlink" title="SUN公司的 HotSpot VM"></a><strong>SUN公司的 HotSpot VM</strong></h3><h4 id="HotSpot历史"><a href="#HotSpot历史" class="headerlink" title="HotSpot历史"></a>HotSpot历史</h4><p>·最初由一家名为“Longview Technologies”的小公司设计1997年，此公司被sun收购;2009年，sun公司被甲骨文收购。<br>·JDK1.3时，HotSpot VM成为默认虚拟机<br>·目前Hotspot占有绝对的市场地位，称霸武林。<br>    不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot<br>    sun/ oracle JDK 和 OpenJDK的默认虚拟机<br>    因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。(比如其他两个商用虚拟机都没有方法区的概念)<br>·从服务器、桌面到移动端、嵌入式都有应用。<br>·名称中的HotSpot指的就是它的热点代码探测技术。<br>    通过计数器找到最具编译价值代码，触发即时编译或栈上替换<br>    通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p>
<h3 id="BEA-的JRockit"><a href="#BEA-的JRockit" class="headerlink" title="BEA 的JRockit"></a>BEA 的JRockit</h3><p>·专注于服务器端应用<br>    它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。<br>·大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。<br>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70% ）和<br>硬件成本的减少(达50%）。<br>·优势:全面的Java运行时解决方案组合<br>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或<br>微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要<br>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产<br>环境中的应用程序的工具。<br> 2008年，BEA被oracle收购。<br>oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。<br>·高斯林:目前就职于谷歌，研究人工智能和水下机器人</p>
<h3 id="IBM-的J9"><a href="#IBM-的J9" class="headerlink" title="IBM 的J9"></a>IBM 的J9</h3><p>全称:IBM Technology for Java virtual Machine，简称IT4J，内部代号:J9<br>·市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM。<br>·广泛用于IBM的各种Java产品。<br>·目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。<br>·2017年左右，IBM发布了开源J9 VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</p>
<h3 id="KVM和cDC-CL-DC-Hotspot"><a href="#KVM和cDC-CL-DC-Hotspot" class="headerlink" title="KVM和cDC/CL.DC Hotspot"></a>KVM和cDC/CL.DC Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为:CDC/CLDC HotSpot Implementation VM<br>KVM (Kilobyte）是CLDC-HI早期产品<br>·目前移动领域地位尴尬，智能手机被Android和ioS二分天下。<br>.KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场<br>    智能控制器、传感器I<br>    老人手机、经济欠发达地区的功能手机<br>.所有的虚拟机的原则:一次编译，到处运行。</p>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>·前面三大“高性能Java虚拟机”使用在通用硬件平台上<br>·这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机<br>    高性能Java虚拟机中的战斗机。<br>Azul VM是Azul systems公司在HotSpot基础上进行大量改进，运行于Azul systems公司的专有硬件vega系统上的Java虚拟机。<br>·每个Azul VM实例都可以管理至少数十个CPu和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的Gc时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。<br>2010年，Azul systems公司开始从硬件转向软件，发布了自己的ZingJVM，可以在通用x86平台上提供接近于Vega系统的特性。T</p>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>·高性能Java虚拟机中的战斗机。<br>·BEA公司开发的，直接运行在自家Hypervisor系统上<br>·Liquid VM即是现在的JRockit VE(Virtual Edition） ,LiquidVM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。<br>·随着JRockit虚拟机终止开发，Liquid VM项目也停止了。</p>
<h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><p> Apache也曾经推出过与JDK 1.5和JDK 1.6兼容的Java运行平台Apache Harmony。<br>·它是IBM和Intel联合开发的开源JVM，受到同样开源的openJDK的压制，<br>sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK<br>·虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java<br>类库代码吸纳进了Android SDK。</p>
<h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><p>·微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。·只能在window平台下运行。但确是当时windows下性能最好的Java VM.. 1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。l</p>
<h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><p>·由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金雷生切一电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大重的开源广的。<br>·基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。<br>·基于openJDK HotSpot VM 发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。<br>    创新的GCIH (Gc invisible heap ）技术实现了off-heap ，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java 对象，以此达到降低GC的回收频率和提升GC 的回收效率的目的。<br>    GCIH 中的对象还能够在多个Java虚拟机进程中实现共享<br>    使用crc32指令实现JVM intrinsic降低JNI 的调用开销<br>    PMU hardware 的Java profiling tool和诊断协助功能<br>    针对大数据场景的ZenGC<br>. taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu，损失了兼容性，但提高了性能<br>    目前已经在淘宝、天猫上线，把oracle 官方JVM版本全部替换了。</p>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM :"></a>Dalvik VM :</h3><p>·谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。.Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循<br>Java虚拟机规范<br>·不能直接执行Java 的class 文件·基于寄存器架构，不是jvm的栈架构。<br>·执行的是编译以后的dex(Dalvik Executable）文件。执行效率比较高<br>    它执行的dex (Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。<br>·Android 5.0使用支持提前编译(Ahead of Time Compilation，AOT）的ARTVM替换Dalvik VM。</p>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>. 2018年4月，oracle Labs公开了Graal VM，号称”Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。<br>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括: Java、Scala、Groovy、Kotlin;C、C++<br>Javascript、Ruby、Python、R等<br>·支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。<br>如果说HotSpot有一天真的被取代，Graal VM希望最大。但是Java的软件生态没有丝毫变化。</p>
<h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="1-内存简图"><a href="#1-内存简图" class="headerlink" title="1.内存简图"></a>1.内存简图</h2><p><img src="https://gitee.com/mychimei/picture/raw/master/work/第02章_JVM架构-简图.jpg" style="zoom: 50%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg" style="zoom: 50%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD.jpg" style="zoom: 50%;" /></p>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><p>​    类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。<br>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。<br>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211115193632367.png" alt="image-20211115193632367"></p>
<h2 id="3-类加载器ClassLoader角色"><a href="#3-类加载器ClassLoader角色" class="headerlink" title="3.类加载器ClassLoader角色"></a>3.类加载器ClassLoader角色</h2><ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file 加载到JVM中，被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt; JVM -&gt;最终成为元数据模板，此过程就要一个运输工具(类装载器class Loader)，扮演一个快递员的角色。</li>
</ol>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211115194329061.png" alt="image-20211115194329061"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116140445121.png" alt="image-20211116140445121"></p>
<h3 id="获取ClassLoader途经"><a href="#获取ClassLoader途经" class="headerlink" title="获取ClassLoader途经"></a>获取ClassLoader途经</h3><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116140425056.png" alt="image-20211116140425056"></p>
<h2 id="4-类加载过程"><a href="#4-类加载过程" class="headerlink" title="4.类加载过程"></a>4.类加载过程</h2><p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC02%E7%AB%A0_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="image-20211115194329061" style="zoom: 50%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211115194822559.png" alt="image-20211115194329061" style="zoom: 80%;" /></p>
<h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading):"></a>加载(Loading):</h3><p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．在内存中生成一个代表这个类的 <strong>java.lang.Class</strong> 对象，作为方法区这个类的各种数据的访问入口<br>补充:加载.class文件的方式<br>·从本地系统中直接加载<br>·通过网络获取，典型场景: web Applet<br>·从zip压缩包中读取，成为日后jar、 war格式的基础·运行时计算生成，使用最多的是:动态代理技术<br>·由其他文件生成，典型场景:JSP应用<br>·从专有数据库中提取.class文件,比较少见<br>·从加密文件中获取，典型的防class文件被反编译的保护措施</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify):"></a>验证(Verify):</h4><p>·目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。<br>·主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare):"></a>准备(Prepare):</h4><p>·为类变量分配内存并且设置该类变量的默认初始值，即零值。<br>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式链初始化;<br>·这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
<h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve) :"></a>解析(Resolve) :</h4><p>·将常量池内的符号引用转换为直接引用的过程。<br>·事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。<br>·符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<br>·解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT Class info、CONSTANT Fieldref_info、CONSTANT _Methodref_info等.。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p>·初始化阶段就是执行类构造器方法<clinit> ()的过程。<br>·此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。<br>·构造器方法中指令按语句在源文件中出现的顺序执行。<br>. <clinit> ()不同于类的构造器。(关联:构造器是虚拟机视角下的<init>( ))·若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit> ()已经执行完毕。<br>·虚拟机必须保证一个类的<clinit> ()方法在多线程下被同步加锁。</p>
<h2 id="5-类加载器分类"><a href="#5-类加载器分类" class="headerlink" title="5.类加载器分类"></a>5.类加载器分类</h2><p>JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>(User-Defined ClassLoader)。<br>·从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br>·无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示:</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116133613669.png" alt="image-20211116133613669"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116133718130.png" alt="image-20211116133718130"></p>
<p>虚拟机自带的加载器</p>
<h3 id="·启动类加载器（引导类加载器，Bootstrap-classLoader"><a href="#·启动类加载器（引导类加载器，Bootstrap-classLoader" class="headerlink" title="·启动类加载器（引导类加载器，Bootstrap classLoader)"></a>·启动类加载器（引导类加载器，Bootstrap classLoader)</h3><p>这个类加载使用<strong>C/C++</strong>语言实现的，嵌套在JVM内部。<br>它用来加载Java的<strong>核心库</strong>（JAVA HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类<br>并不继承自java.lang.classLoader，没有父加载器。加载扩展类和应用程序类加载器，并指定为他们的父类加载器。<br>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java、javax、sun</strong>等开头的类</p>
<h3 id="·扩展类加载器（Extension-ClassLoader"><a href="#·扩展类加载器（Extension-ClassLoader" class="headerlink" title="·扩展类加载器（Extension ClassLoader)"></a>·扩展类加载器（Extension ClassLoader)</h3><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。派生于classLoader类<br>父类加载器为启动类加载器<br>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的<strong>jre/lib/ext</strong>子目录（扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
<h3 id="·应用程序类加载器（系统类加载器，AppClassLoader"><a href="#·应用程序类加载器（系统类加载器，AppClassLoader" class="headerlink" title="·应用程序类加载器（系统类加载器，AppClassLoader)"></a>·应用程序类加载器（系统类加载器，AppClassLoader)</h3><p>java语言编写，由sun.misc.Launcher$AppclassLoader实现&gt;派生于classLoader类<br>父类加载器为扩展类加载器<br>它负责加载环境变量classpath或系统属性java.class.<strong>path</strong>指定路径下的类库<br>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载<br>通过classLoader#getSystemClassLoader ()方法可以获取到该类加载器</p>
<h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a><strong>用户自定义类加载器</strong></h4><p>·在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互<br>配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>.为什么要自定义类加载器?<br>隔离加载类<br>修改类加载的方式<br>扩展加载源<br>防止源码泄漏</p>
<h4 id="用户自定义类加载器实现步骤"><a href="#用户自定义类加载器实现步骤" class="headerlink" title="用户自定义类加载器实现步骤:"></a><strong>用户自定义类加载器实现步骤:</strong></h4><p>1.开发人员可以通过继承抽象类java.lang.classLoader类的方式，实现自己的类加载器，以满足一些特殊的需求<br>2.在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadClass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass ()方法中<br>3．在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass ()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<h2 id="6-双亲委派机制"><a href="#6-双亲委派机制" class="headerlink" title="6.双亲委派机制"></a>6.双亲委派机制</h2><p>​    Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理,它是一种任务委派模式。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>1)如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求<strong>委托给父类</strong>的加载器去执行;<br>2)如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器;<br>3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116182608650.png" alt="image-20211116182608650"></p>
<h3 id="双亲委派优势"><a href="#双亲委派优势" class="headerlink" title="双亲委派优势"></a><strong>双亲委派优势</strong></h3><p>避免类的重复加载<br>保护程序安全，防止核心API被随意篡改<br>    自定义类:java. lang. string<br>    自定义类: java . lang. shkStart<br>java.lang. securityException: Prohibited package name: java.lang</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211116183030909.png" alt="image-20211116183030909"></p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>​    自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7.其他"></a>7.其他</h2><p>·在JVM中表示两个class对象是否为同一个类存在两个必要条件:<br>    类的完整类名必须一致，包括包名。<br>    加载这个类的classLoader(指classLoader实例对象)必须相同。<br>·换句话说，在VM中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<h3 id="对类加载其的引用"><a href="#对类加载其的引用" class="headerlink" title="对类加载其的引用"></a><strong>对类加载其的引用</strong></h3><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为:主动使用和被动使用。·主动使用，又分为七种情况:<br>·创建类的实例<br>·访问某个类或接口的静态变量，或者对该静态变量赋值<br>·调用类的静态方法<br>·反射（比如: Class.forName ( “com.atguigu . Test”) )&gt;<br>·初始化一个类的子类<br>·Java虚拟机启动时被标明为启动类的类<br>·JDK 7开始提供的动态语言支持:java . lang.invoke.MethodHandle实例的解析结果REF getstatic、REF putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化<br>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
<h1 id="三、运行时数据区概述及线程"><a href="#三、运行时数据区概述及线程" class="headerlink" title="三、运行时数据区概述及线程"></a>三、<em>运行时数据区概述及线程</em></h1><h2 id="1-运行时数据区内部结构"><a href="#1-运行时数据区内部结构" class="headerlink" title="1.运行时数据区内部结构"></a>1.运行时数据区内部结构</h2><p>​        内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Error</th>
<th>GC</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td>:x:</td>
<td>:x:</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>:heavy_check_mark:</td>
<td>:x:</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>:heavy_check_mark:</td>
<td>:x:</td>
</tr>
<tr>
<td>堆</td>
<td>:heavy_check_mark:</td>
<td>:heavy_check_mark:</td>
</tr>
<tr>
<td>方法区</td>
<td>:heavy_check_mark:</td>
<td>:heavy_check_mark:</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117173714222.png" alt="image-20211117173714222" style="zoom: 67%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117173754033.png" alt="image-20211117173754033" style="zoom: 67%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117174004750.png" alt="image-20211117174004750" style="zoom: 67%;" /></p>
<p>​        Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。灰色的为单独线程私有的，红色的为多个线程共享的。即:每个线程:独立包括程序计数器、栈、本地栈。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="第03章_线程共享和私有的结构" style="zoom:50%;" /></p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p>​        线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<br>​        当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run ()方法。</p>
<p>​        如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main (string[])的main线程以及所有这个main线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几个:</p>
<p><strong>虚拟机线程:</strong>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种         线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。<br><strong>周期任务线程:</strong>这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行。<br><strong>GC线程:</strong>这种线程对在JVM里不同种类的垃圾收集行为提供了支持。&gt;编译线程:这种线程在运行时会将字节码编译成到本地代码。<br><strong>信号调度线程:</strong>这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</p>
<p>·线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>.在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。<br>·操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run ()方法。<br>●守护线程、普通线程</p>
<h1 id="四、程序计数器"><a href="#四、程序计数器" class="headerlink" title="四、程序计数器"></a>四、<em>程序计数器</em></h1><h3 id="1-Program-Counter-Register介绍"><a href="#1-Program-Counter-Register介绍" class="headerlink" title="1.Program Counter Register介绍"></a>1.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javaselspecs/jvms/se8/html/">Program Counter Register介绍</a></h3><p>​        JVM中的程序计数寄存器(Program counter Register)中， Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为Pc计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。JVM中的Pc寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117141024972.png" alt="image-20211117141024972" style="zoom: 67%;" /></p>
<p>作用:<br>PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117141325424.png" alt="image-20211117141325424"></p>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。<br>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。<br>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的TVM指令地址;或者，如果是在执行native方法，则是未指定值（undefned) 。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。<br>它是唯一一个在Java虚拟机规范中没有规定任何outOtMemoryError情况的区域。</p>
<h3 id="2-程序示例"><a href="#2-程序示例" class="headerlink" title="2.程序示例"></a>2.程序示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v/verbose （<span class="class"><span class="keyword">class</span>名） //反编译</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211117141655513.png" alt="image-20211117141655513" style="zoom:67%;" /></p>
<h3 id="3-两个问题"><a href="#3-两个问题" class="headerlink" title="3.两个问题"></a>3.两个问题</h3><h4 id="（1）使用PC寄存器存储字节码指令地址有什么用呢-为什么使用PC寄存器记录当前线程的执行地址呢？"><a href="#（1）使用PC寄存器存储字节码指令地址有什么用呢-为什么使用PC寄存器记录当前线程的执行地址呢？" class="headerlink" title="（1）使用PC寄存器存储字节码指令地址有什么用呢?为什么使用PC寄存器记录当前线程的执行地址呢？"></a><strong>（1）使用PC寄存器存储字节码指令地址有什么用呢?为什么使用PC寄存器记录当前线程的执行地址呢？</strong></h4><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br>JVM的字节码解释器就需要通过改变Pc寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="第04章_PC寄存器" style="zoom: 50%;" /></p>
<h4 id="2-PC寄存器为什么会被设定为线程私有"><a href="#2-PC寄存器为什么会被设定为线程私有" class="headerlink" title="(2)PC寄存器为什么会被设定为线程私有?"></a><strong>(2)PC寄存器为什么会被设定为线程私有?</strong></h4><p>​        我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个Pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。</p>
<p>​        CPU时间片即cPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。在宏观上:我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上:由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<h1 id="五、虚拟机栈"><a href="#五、虚拟机栈" class="headerlink" title="五、虚拟机栈"></a>五、虚拟机栈</h1><h3 id="1-栈主要特点"><a href="#1-栈主要特点" class="headerlink" title="1.栈主要特点"></a>1.栈主要特点</h3><p>​        由于跨半台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。<strong>栈是运行时的单位，而堆是存储的单位。</strong>即：機解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。       </p>
<h4 id="・Java虚拟机栈是什么？"><a href="#・Java虚拟机栈是什么？" class="headerlink" title="・Java虚拟机栈是什么？"></a><strong>・Java虚拟机栈是什么？</strong></h4><p>Java虚拟机栈( Java Virtual Machine Stack),早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧( Stack Frame),对应着一次次的Java方法调用，<strong>是线程私有的。生命周期和线程一致</strong>。</p>
<h4 id="・作用"><a href="#・作用" class="headerlink" title="・作用"></a><strong>・作用</strong></h4><p>主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。<br>局部变量vs成员变量（或属性）<br>基本数据变量vs引用类型变量(类、数组、接口)       </p>
<h4 id="・栈的特点（优点）"><a href="#・栈的特点（优点）" class="headerlink" title="・栈的特点（优点）"></a><strong>・栈的特点（优点）</strong></h4><p>栈是一种快速有效的分配存储方式，访问速度仪次于程序计数器。<br>JWM直接对Java機的操作只有两个：<br>每个方法执行，伴随着进機(入栈、压栈)<br>执行结束后的出栈工作<br>对于栈来说不存在垃圾回收问题                </p>
<h3 id="2-栈中可能出现的异常"><a href="#2-栈中可能出现的异常" class="headerlink" title="2.栈中可能出现的异常"></a>2.栈中可能出现的异常</h3><p>​        Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<br>​        如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p>​        如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError异常。</p>
<h4 id="设置栈大小"><a href="#设置栈大小" class="headerlink" title="设置栈大小"></a><strong>设置栈大小</strong></h4><blockquote>
<p>Xss size<br>Sets the thread stack size( in bytes). Append the letter k or K to indicate KB, m or M to indicate MB, and g or G to indicate<br>GB. The default value depends on the platform<br>Linux/x64(64-bit): 1024 KB<br>macos(64-bit): 1024 KB<br>Oracle Solaris/x64(64-bit): 1024 KB<br>Windows: The default value depends on virtual memory<br>The following examples set the thread stack size to 1024 KB in different units<br>-Xss1m<br>-Xss1024k<br>Xss1048576</p>
</blockquote>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122140441632.png" alt=""></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122140406127.png" alt="image-20211122140406127" style="zoom: 80%;" /></p>
<h3 id="3-栈存储单位"><a href="#3-栈存储单位" class="headerlink" title="3.栈存储单位"></a>3.栈存储单位</h3><p>栈中存储什么<br>・每个线程都有自己的栈，栈中的数据都是以栈帧( Stack Frame)的格式存在。<br>・在这个线程上正在执行的每个方法都各自对应一个栈帧( Stack Frame)<br>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息<br>复习<br>・OOP的基本概念：类、对象<br>・类中基本结构：fie1d(属性、字段、域)、 method</p>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的栈和出栈，遵循“先进后出”/“后进先出”原则。<br>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧( Current Frame),与当前栈帧相对应的方法就是当前方法（ Current Method),定义这个方法的类就是当前类( Current C1ass).<br>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。<br>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122183152431.png" alt="image-20211122183152431"></p>
<p>・不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧<br>・如果当前方法调用了其他方法，方法返回之际，当前機帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。<br>・Java方法有两种返回函数的方式，一种是正常的函数返回，使用 return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h3 id="4-栈结构"><a href="#4-栈结构" class="headerlink" title="4.栈结构"></a>4.栈结构</h3><p><strong>・局部变量表(Local variables)</strong><br><strong>・操作数栈( Operand stack)（或表达式栈）</strong><br>・动态链接( Dynamic Linking)（或指向运行时常量池的方法引用）<br>・方法返回地址( Return Address)（或方法正常退出或者异常退出的定义）<br>・一些附加信息</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="第05章_栈桢内部结构"></p>
<h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表"></a>1.局部变量表</h4><p>・局部变量表也被称之为局部变量数组或本地变量表<br>・定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用( reference),以及returnAddress类型。<br>・由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题<br>・局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的 maximuim local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>・方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息増大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。<br>・局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h4 id="2-字节码中方法内部结构解析"><a href="#2-字节码中方法内部结构解析" class="headerlink" title="2.字节码中方法内部结构解析"></a>2.字节码中方法内部结构解析</h4><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122190700864.png" alt="image-20211122190700864"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122191003982.png" alt="image-20211122191003982"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122191207552.png" alt="image-20211122191207552"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122192009824.png" alt="image-20211122192009824"></p>
<h4 id="3-Slot"><a href="#3-Slot" class="headerlink" title="3.Slot"></a>3.Slot</h4><p>・参数值的存放总是在局部变量数组的 index0开始，到数组长度-1的索引结束<br>・局部变量表，最基本的存储单元是Slot（变量槽）<br>・局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型( reference), returnAddressa类型。<br>・在局部变量表里，32位以内的类型只占用一个slot(包括returnAddressa类型），64位的类型(long和 double)占用两个slot.<br>        byte、 short、char在存储前被转换为int, boolean也被转换为int,0表示 false,非0表示true。<br>        long和double则占据两个Slot。</p>
<p>・JVM会为局部变量表中的每一个Slot都分配一个访问素引，通过这个素引即可成功访问到局部变量表中指定的局部变量值.<br>・当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上.<br>・如果需要访问局部变量表中ー个64bit的局部变量值时，只需要使用前一个素引即可。(比如：访问1ong或doub1e类型变量).<br>・如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在 index为0的slot处，其余的参数按照参数表顺序继续排列.</p>
<p>​        栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211122195538822.png" alt="image-20211122195538822" style="zoom: 67%;" /></p>
<h4 id="7-静态变量和局部变量对比"><a href="#7-静态变量和局部变量对比" class="headerlink" title="7.静态变量和局部变量对比"></a>7.静态变量和局部变量对比</h4><p>$\triangleright$ 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配<br>$\triangleright$ 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值.<br>$\triangleright$ 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样的代码是错误的，没有赋值不能够使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">System.out .println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变量的分类：</strong><br>$\triangleright$ 按照数据类型分：基本数据类型、引用数据类型<br>$\triangleright$ 按照在类中声明的位置分：成员变量：在使用前，都经历过默认初始化赋值<br>        类变量： Linking的 prepare阶段：给类变量默认赋值–&gt;initial阶段：给静态代码块赋值<br>        实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>$\triangleright$ 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</p>
<p><strong>补充说明</strong><br>$\triangleright$ 在栈帧中 ， 与性能调优关系最为密切的部分就是前面提到的局部变量表 。在方法执行时 ， 虚拟机使用局部变量表完成方法的传递 。<br>$\triangleright$ 局部变量表中的变量也是重要的垃圾回收根节点 ， 只要被局部变量表中直接或间接引用的对象都不会被回收 。</p>
<h4 id="8-操作数栈"><a href="#8-操作数栈" class="headerlink" title="8.操作数栈"></a>8.操作数栈</h4><p>$\triangleright$ 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-0ut)的操作数栈，也可以称之为表达式栈(Expression Stack).<br>$\triangleright$ 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).<br>        某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</p>
<p>$\triangleright$ 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。<br>$\triangleright$ 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。<br>$\triangleright$ 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<p>$\triangleright$ 操作数栈，主要用于<strong>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong><br>$\triangleright$ 操作数栈就是JVM执行引擎的-一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是<strong>空的</strong>。<br>$\triangleright$ 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max stack的值。<br>$\triangleright$ 栈中的任何一个元素都是可以任意的Java数据类型。<br>    ➢32bit的类型占用一个栈单位深度<br>    ➢64bit的类型占用两个栈单位深度<br>$\triangleright$ 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push) 和出栈(pop)操作来完成一次数据访问。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span> i=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> k=i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图例：</strong></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140047087.png" alt="image-20211123140047087"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140228419.png" alt="image-20211123140228419"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140302504.png" alt="image-20211123140302504"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140320706.png" alt="image-20211123140320706"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140346031.png" alt="image-20211123140346031"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140429125.png" alt="image-20211123140429125"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140450391.png" alt="image-20211123140450391"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123140754907.png" alt="image-20211123140754907"></p>
<h4 id="9-栈顶缓存（Top-of-Stack-Cashing）技术"><a href="#9-栈顶缓存（Top-of-Stack-Cashing）技术" class="headerlink" title="9.栈顶缓存（Top-of-Stack-Cashing）技术"></a>9.栈顶缓存（Top-of-Stack-Cashing）技术</h4><p>$\star$  前面提过，基于栈式架构的虛拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派( instruction dispatch)次数和内存读/写次数。<br>$\star$  由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题， Hotspot JVM的设计者们提出了栈顶缓存(ToS,Top-of- Stack Cashing)技术，将<strong>栈顶元素全部缓存在物理CPU的寄存器</strong>中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h4 id="10-动态链接"><a href="#10-动态链接" class="headerlink" title="10.动态链接"></a>10.动态链接</h4><p>$\star$ 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如： invokedynamic指令<br>$\star$ 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用( Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了<strong>将这些符号引用转换为调用方法的直接引用。</strong></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211123190249212.png" alt="image-20211123190249212"></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC09%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E6%A0%88%E7%9A%84%E5%85%B3%E8%81%94%E7%BB%93%E6%9E%84.jpg" alt="第09章_方法区与栈的关联结构"></p>
<h4 id="11-方法的调用"><a href="#11-方法的调用" class="headerlink" title="11.方法的调用"></a><strong>11.方法的调用</strong></h4><p>在JWM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。<br><strong>静态链接：</strong><br>$\star$ 当一个字节码文件被装载进JWM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接<br><strong>动态链接：</strong><br>$\star$ 如果被调用的方法在<strong>编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
<p>对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定( Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。<br><strong>早期绑定：</strong><br>$\star$ 早期绑定就是指被调用的目标方法如果在<strong>编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。<br><strong>晚期绑定：</strong><br>$\star$ 如果被调用的方法在<strong>编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
<p>$\star$ 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。<br>$\star$ Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C  语言中的虚函数(C  中则需要使用关键字 virtua1来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字fina1来标记这个方法。</p>
<h4 id="12-虚方法、非虚方法"><a href="#12-虚方法、非虚方法" class="headerlink" title="12.虚方法、非虚方法"></a>12.虚方法、非虚方法</h4><p><strong>非虚方法：</strong><br>        如果方法在<strong>编译期就确定了具体的调用版本</strong>，这个版本在<strong>运行时是不可变</strong>的。这样的方法称为非虚方法。<strong>静态方法、私有方法、final方法、实例构造器、父类方法</strong>都是<strong>非虚方法</strong>，其他方法称为虚方法。</p>
<p>​        随着高级语言的横空出世，类似于Javaー样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的<strong>编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</strong><br>​        Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数(C++中则需要使用关键字 virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p>虚拟机中提供了以下几条方法调用指令</p>
<p><strong>普通调用指令</strong></p>
<ol>
<li>invokestatic:调用<strong>静态</strong>方法，解析阶段确定唯一方法版本</li>
<li>invokespecial:调用<strong><init></strong>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>involkevirtual:调用所有虚方法</li>
<li>invokeinterface:调用接口方法</li>
</ol>
<p><strong>动态调用指令</strong></p>
<ol>
<li>invokedynamic:动态解析出需要调用的方法，然后执行前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic指令则支持由用户确定方法版本。其中 <strong>invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的( final 修饰的除外)称为虚方法。</strong></li>
</ol>
<h4 id="13-Invokedynamic"><a href="#13-Invokedynamic" class="headerlink" title="13.Invokedynamic"></a>13.Invokedynamic</h4><p>$\star$ JVM字节码指令集一直比较稳定，一直到Java7中オ増加了一个 invokedynamic 指令，这是 Java 为了实现「动态类型语言」支持而做的种改进。<br>$\star$ 但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，nvokedynamic 指令的生成，在 Java 中才有了直接的生成方式。<br>$\star$ Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p>
<p><strong>动态类型语言和静态类型语言</strong><br>        动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言（比如Python）的一个重要特征。</p>
<h4 id="14-方法重写本质"><a href="#14-方法重写本质" class="headerlink" title="14.方法重写本质"></a>14.方法重写本质</h4><p><strong>Java语言中方法重写的本质</strong><br>1.找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C<br>2.如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，査找过程结束；如果不通过，则返回java.lang.Illegal AccessError异常。<br>3.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。<br>4.如果始终没有找到合适的方法，则抛出java.lang. AbstractMethodError异常。<br><strong>Illegal Accessarror介绍：</strong><br>        程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<p>・在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，JVM采用在类的方法区建立一个<strong>虚方法表</strong>( virtual method tabble)（非虚方法不会出现在表中）来实现。使用索引表来代替查找。<br>・每个类中都有一个虚方法表，表中存放着各个方法的实际入口<br>・那么虚方法表什么时候被创建？<br>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JWM会把该类的方法表也初始化完毕。</p>
<h4 id="15-方法返回地址"><a href="#15-方法返回地址" class="headerlink" title="15.方法返回地址"></a>15.方法返回地址</h4><p>存放调用该方法的pc寄存器的值。</p>
<p><strong>一个方法的结束，有两种方式：</strong><br>正常执行完成<br>出现未处理的异常，非正常退出</p>
<p>​        无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>​        本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。<br>​        正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<p>当一个方法开始执行后，只有<strong>两种方式可以退出这个方法</strong><br>1、执行引擎遇到任意一个方法返回的字节码指令( return),会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong></p>
<p>​        一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。<br>​        在字节码指令中，返回指令包含 lreturn(当返回值是 boolean、byte、char、shorth和int类型时使用)、lreturn、 freturn、 dreturn以及 areturn,另外还有一个 return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p>
<p>2、在方法执行的过程中遇到了异常( Exception),并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。<br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<h4 id="16-一些附加信息-略"><a href="#16-一些附加信息-略" class="headerlink" title="16.一些附加信息(略)"></a>16.一些附加信息(略)</h4><h2 id="17-面试题"><a href="#17-面试题" class="headerlink" title="17.面试题"></a>17.面试题</h2><p>举例栈溢出的情况？( StackOverflowError)<br>通过-Xss设置栈的大小；OOM<br>调整栈大小，就能保证不出现溢出吗？不能<br>分配的栈内存越大越好吗？不是<br>垃圾回收是否会涉及到虚拟机栈？不会的！<br>方法中定义的局部变量是否线程安全？具体问题具体分析</p>
<h1 id="六、本地方法接口"><a href="#六、本地方法接口" class="headerlink" title="六、本地方法接口"></a>六、<em>本地方法接口</em></h1><p><strong>什么是本地方法？</strong><br>简单地讲，一个 Native Methodl就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C.这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C  中，你可以用 extern”c”告知C  编译器去调用一个C的函数。</p>
<blockquote>
<p>A native method is a Java method whose Implementation is provided by non-java code</p>
</blockquote>
<p>在定义ー个 native method时，并不提供实现体(有些像定义ー个Javai nterface),因为其实现体是由非java语言在外面实现的。<br>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211124202600273.png" alt="image-20211124202600273" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211124202817626.png" alt="image-20211124202817626" style="zoom:80%;" /></p>
<p><strong>为什么要使用 Native Method?</strong><br>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。<br>・与Java环境外交互：<strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口而且我们无需去了解Java应用之外的繁琐的细节。</p>
<p><strong>与操作系统交互</strong><br>        JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。<br><strong>Sun’s Java</strong><br>        <strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</strong>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang. hread的 setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setprlority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 Setpriority（）API。这是一个本地方法的具体实现由JM直接提供，更多的情况是本地方法由外部的动态链接库( external dynamic link library)提供，然后被JVM调用。</p>
<p><strong>现状</strong></p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用网 Web Service等等，不多做介绍。</p>
<h1 id="七、本地方法栈"><a href="#七、本地方法栈" class="headerlink" title="七、本地方法栈"></a>七、<em>本地方法栈</em></h1><p>本地方法栈( Native Method Stack)<br>・Java虚拟机栈用于管理Java方法的调用，而本地方法用于管理本地方法的调用。<br>・本地方法栈，也是线程私有的。<br>・允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<p>​        如果线程请求分配的機容量超过本地方法機允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError异常。<br>​        如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError异常<br>・本地方法是使用C语言实现的<br>・它的具体做法是 Native Method Stack中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
<p>・当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<br>        本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。<br>        它甚至可以直接使用本地处理器中的寄存器<br>        直接从本地内存的堆中分配任意数量的内存。<br>并不是所有的JWM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JM产品不打算支持 native方法，也可以无需实现本地方法栈。<br>・在 Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h1 id="八、堆"><a href="#八、堆" class="headerlink" title="八、堆"></a><strong>八、堆</strong></h1><h2 id="1-堆的核心概述"><a href="#1-堆的核心概述" class="headerlink" title="1.堆的核心概述"></a>1.堆的核心概述</h2><p>・一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。<br>・Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的<br>・所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（ Thread Local Allocation Buffer, TLAB)</p>
<p>・《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（ The heap is the run-time data area fromwhich memcry for all class instances and arrays is allocated)我要说的是：“几乎”所有的对象实例都在这里分配内存。一从实际使用角度看的。<br>・数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。<br>・在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<br>・堆，是GC( Garbage Collection,垃圾收集器)执行垃圾回收的重点区域。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125134653273.png" alt="image-20211125134653273" style="zoom: 50%;" /></p>
<h2 id="2-堆的细分内存结构"><a href="#2-堆的细分内存结构" class="headerlink" title="2.堆的细分内存结构"></a>2.堆的细分内存结构</h2><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125135924933.png" alt="image-20211125135924933" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125140503796.png" alt="image-20211125140503796"></p>
<h2 id="3-设置堆内存大小与OOM"><a href="#3-设置堆内存大小与OOM" class="headerlink" title="3.设置堆内存大小与OOM"></a>3.设置堆内存大小与OOM</h2><h3 id="1-设置堆内存"><a href="#1-设置堆内存" class="headerlink" title="1.设置堆内存"></a>1.设置堆内存</h3><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置</p>
<p>​    “-Xms”用于表示堆区的起始内存，等价于ーXX: Initialheapsize<br>​    “-Xmx”则用于表示堆区的最大内存，等价于ーXX: Maxheapsize<br>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。<br>・通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。默认情况下：初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4</p>
<p>4.查看设置的参数：方式一：jps/jstat -gc 进程id<br>                                方式二：-XX:  +Printgcdetails</p>
<h3 id="2-OOM说明与举例"><a href="#2-OOM说明与举例" class="headerlink" title="2.OOM说明与举例"></a>2.OOM说明与举例</h3><h5 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h5><p>jvisualvm：查看内存情况，jvisualvm命令可直接打开</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125191145594.png" alt="image-20211125191145594"></p>
<h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125191600977.png" alt="image-20211125191600977"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Picture1&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="keyword">new</span> Picture1(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span>*<span class="number">1024</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">byte</span>[] pixels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture1</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h5><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125192134417.png" alt="image-20211125192134417"></p>
<h5 id="修改堆大小"><a href="#修改堆大小" class="headerlink" title="修改堆大小"></a>修改堆大小</h5><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125192042179.png" alt="image-20211125192042179"></p>
<h5 id="运行程序查看-jvisualvm"><a href="#运行程序查看-jvisualvm" class="headerlink" title="运行程序查看 jvisualvm"></a>运行程序查看 jvisualvm</h5><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211125193145169.png" alt="image-20211125193145169"  /></p>
<p>Exception in thread “main” java.lang.<strong>OutOfMemoryError</strong>: Java heap space<br>    at pers.lxl.mylearnproject.programbase.jvm.Picture1.<init>(OOMInstance.java:27)<br>    at pers.lxl.mylearnproject.programbase.jvm.OOMInstance.main(OOMInstance.java:19)</p>
<h2 id="4-年轻代与老年代"><a href="#4-年轻代与老年代" class="headerlink" title="4.年轻代与老年代"></a>4.年轻代与老年代</h2><p>・存储在JVM中的Java对象可以被划分为两类<br>        一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<br>        另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。<br>・Java堆区进一步细分的话，可以划分为年轻代( YoungGen)和老年代( OldGen)<br>・其中年轻代又可以划分为Eden空间、 Survivor0空间和 Survivor1空间(有时也叫做from区、to区)。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211126133609902.png" alt="image-20211126133609902" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211126133644542.png" alt="image-20211126133644542"></p>
<h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><p>配置新生代与老年代在堆结构的占比。<br>默认<strong>-XX: NewRatio=2</strong>,表示新生代占1,老年代占2,新生代占整个堆的1/3<br>可以修改-XX: Newratio=4,表示新生代占1,老年代占4,新生代占整个堆的1/5</p>
<p>在 Hot Spot中，Eden究间和另外两个 Survivor’空间缺省所占的比例是8:1:1当然开发人员可以通过选项“<strong>-Xx: SurvivorRatio</strong>”调整这个空间比例。比如XX: Survivorratio=8,默认8<br>几乎所有的Java对象都是在Eden区被new出来的绝大部分的Java对象的销毁都在新生代进行了。IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。<br>可以使用选项”<strong>-Xmn</strong>‘“设置新生代最大内存大小&gt;这个参数一般使用默认值就可以了。</p>
<h3 id="对象流程："><a href="#对象流程：" class="headerlink" title="对象流程："></a>对象流程：</h3><p><img src="https://gitee.com/mychimei/picture/raw/master/work/image-20211126133944542.png" alt="image-20211126133944542"></p>
<h2 id="5-对象分配过程"><a href="#5-对象分配过程" class="headerlink" title="5.对象分配过程"></a>5.对象分配过程</h2><p>​        Eden 满触发 YGC/Minor GC 对 Eden与 From 区回收，还在用的对象放到 From 区，Age设为1，下次回收触发时复制 From 区转到 To 区（空的区），Age+1，Age 达到阈值（可通过设置  -XX: MaxTenuringThreshold=<N>）放入Old。</p>
<p><img src="https://gitee.com/mychimei/picture/raw/master/work/%E7%AC%AC08%E7%AB%A0_%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpg" alt="第08章_新生代对象分配与回收过程"></p>
<p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑Gc执行完内存回收后是否会在内存空间中爬生内存碎片。<br>1.new的对象先放伊甸园区。此区有大小限制。<br>2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收( Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。<br>3.然后将伊甸园中的剩余对象移动到幸存者0区<br>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br>5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区<br>6.啥时候能去养老区呢？可以设置次数。默认是15次。可以设置参数：-XX: MaxTenuringThreshold=<N>进行设置。</p>
<p>总结<br>针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是To<br>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p>
<h1 id="九、方法区"><a href="#九、方法区" class="headerlink" title="九、方法区"></a>九、方法区</h1><h1 id="十、直接内存"><a href="#十、直接内存" class="headerlink" title="十、直接内存"></a>十、<em>直接内存</em></h1><h1 id="十一、执行引擎"><a href="#十一、执行引擎" class="headerlink" title="十一、执行引擎"></a>十一、<em>执行引擎</em></h1><h1 id="十二、StringTable"><a href="#十二、StringTable" class="headerlink" title="十二、StringTable"></a>十二、StringTable</h1><h1 id="十三、垃圾回收概述"><a href="#十三、垃圾回收概述" class="headerlink" title="十三、垃圾回收概述"></a>十三、<em>垃圾回收概述</em></h1><h1 id="十四、垃圾回收相关算法"><a href="#十四、垃圾回收相关算法" class="headerlink" title="十四、垃圾回收相关算法"></a>十四、<em>垃圾回收相关算法</em></h1><h1 id="十五、垃圾回收相关概念"><a href="#十五、垃圾回收相关概念" class="headerlink" title="十五、垃圾回收相关概念"></a>十五、<em>垃圾回收相关概念</em></h1><h1 id="十六、垃圾回收器"><a href="#十六、垃圾回收器" class="headerlink" title="十六、垃圾回收器"></a>十六、垃圾回收器</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="article-licensing box"><div class="licensing-title"><p>JVM 与上层技术</p><p><a href="http://mrdemonlxl.github.io/2021/11/10/Draft/2021/JVM 与上层技术/">http://mrdemonlxl.github.io/2021/11/10/Draft/2021/JVM 与上层技术/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://MrDemonlxl.github.io"><p>魑魅先生</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/02/25/Draft/2021/%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86/" target="_blank">魑魅先生 | 音乐</a><br></span><span>  2.<a class="is-size-6" href="/2021/02/25/Draft/2021/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/" target="_blank">魑魅先生 | 程序员英语</a><br></span><span>  3.<a class="is-size-6" href="/2021/02/25/Draft/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" target="_blank">魑魅先生 | 计算机网络</a><br></span><span>  4.<a class="is-size-6" href="/2021/02/25/Draft/2021/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" target="_blank">魑魅先生 | 微信小程序</a><br></span><span>  5.<a class="is-size-6" href="/2021/02/19/Draft/2021/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/" target="_blank">魑魅先生 | 每日算法</a><br></span><span>  6.<a class="is-size-6" href="/2021/07/22/Draft/2021/%E8%B5%84%E6%BA%90%E7%AF%87/" target="_blank">魑魅先生 | 资源篇</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://gitee.com/mychimei/picture/raw/master/1c4f12804cc5a92919acd743d93a869.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://gitee.com/mychimei/picture/raw/master/260e4f4bc9e4053108cd9d02bae7386.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/26/Draft/2021/Markdown%20%E5%AD%A6%E4%B9%A0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Markdown 学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/17/Draft/2021/%E5%B7%A5%E5%85%B7%E7%AF%87/"><span class="level-item">工具篇</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '486d51bdeafd99dbf0aa6c0067a949d5',
            repo: 'MrDemonlxl.github.io',
            owner: 'MrDemonlxl',
            clientID: '20ef8321698ab8c0c37b',
            clientSecret: '4faa4daae14b55afd2ed357fba92d1e9c7c3f729',
            admin: ["MrDemonlxl"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#新学四问"><span>新学四问</span></a></li><li><a class="is-flex is-mobile" href="#进度：上篇-第八章【72】"><span>进度：上篇 第八章【72】</span></a></li><li><a class="is-flex is-mobile" href="#上篇：内存与垃圾回收"><span>上篇：内存与垃圾回收</span></a></li><li><a class="is-flex is-mobile" href="#一、JVM与JAVA体系结构"><span>一、JVM与JAVA体系结构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-JAVA与JVM"><span>1.JAVA与JVM</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Java大事件"><span>Java大事件</span></a></li><li><a class="is-flex is-mobile" href="#JVM介绍"><span>JVM介绍</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#JVM整体结构"><span>JVM整体结构</span></a></li><li><a class="is-flex is-mobile" href="#Java代码执行流程"><span>Java代码执行流程</span></a></li><li><a class="is-flex is-mobile" href="#JVM架构模型"><span>JVM架构模型</span></a></li><li><a class="is-flex is-mobile" href="#JVM生命周期"><span>JVM生命周期</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#启动"><span>启动</span></a></li><li><a class="is-flex is-mobile" href="#执行"><span>执行</span></a></li><li><a class="is-flex is-mobile" href="#退出"><span>退出</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#JVM发展历程"><span>JVM发展历程</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#SUN-Classic-VM"><span>SUN Classic VM</span></a></li><li><a class="is-flex is-mobile" href="#Exact-VM"><span>Exact VM</span></a></li><li><a class="is-flex is-mobile" href="#HotSpot历史"><span>HotSpot历史</span></a></li><li><a class="is-flex is-mobile" href="#BEA-的JRockit"><span>BEA 的JRockit</span></a></li><li><a class="is-flex is-mobile" href="#IBM-的J9"><span>IBM 的J9</span></a></li><li><a class="is-flex is-mobile" href="#KVM和cDC-CL-DC-Hotspot"><span>KVM和cDC/CL.DC Hotspot</span></a></li><li><a class="is-flex is-mobile" href="#Azul-VM"><span>Azul VM</span></a></li><li><a class="is-flex is-mobile" href="#Liquid-VM"><span>Liquid VM</span></a></li><li><a class="is-flex is-mobile" href="#Apache-Harmony"><span>Apache Harmony</span></a></li><li><a class="is-flex is-mobile" href="#Microsoft-JVM"><span>Microsoft JVM</span></a></li><li><a class="is-flex is-mobile" href="#TaobaoJVM"><span>TaobaoJVM</span></a></li><li><a class="is-flex is-mobile" href="#Dalvik-VM"><span>Dalvik VM :</span></a></li><li><a class="is-flex is-mobile" href="#Graal-VM"><span>Graal VM</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#二、类加载子系统"><span>二、类加载子系统</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-内存简图"><span>1.内存简图</span></a></li><li><a class="is-flex is-mobile" href="#2-类加载器"><span>2.类加载器</span></a></li><li><a class="is-flex is-mobile" href="#3-类加载器ClassLoader角色"><span>3.类加载器ClassLoader角色</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#获取ClassLoader途经"><span>获取ClassLoader途经</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#4-类加载过程"><span>4.类加载过程</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#加载-Loading"><span>加载(Loading):</span></a></li><li><a class="is-flex is-mobile" href="#解析-Resolve"><span>解析(Resolve) :</span></a></li><li><a class="is-flex is-mobile" href="#初始化"><span>初始化:</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-类加载器分类"><span>5.类加载器分类</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#·启动类加载器（引导类加载器，Bootstrap-classLoader"><span>·启动类加载器（引导类加载器，Bootstrap classLoader)</span></a></li><li><a class="is-flex is-mobile" href="#·扩展类加载器（Extension-ClassLoader"><span>·扩展类加载器（Extension ClassLoader)</span></a></li><li><a class="is-flex is-mobile" href="#用户自定义类加载器实现步骤"><span>用户自定义类加载器实现步骤:</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-双亲委派机制"><span>6.双亲委派机制</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#工作原理"><span>工作原理</span></a></li><li><a class="is-flex is-mobile" href="#双亲委派优势"><span>双亲委派优势</span></a></li><li><a class="is-flex is-mobile" href="#沙箱安全机制"><span>沙箱安全机制</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#7-其他"><span>7.其他</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#对类加载其的引用"><span>对类加载其的引用</span></a></li><li><a class="is-flex is-mobile" href="#类的主动使用和被动使用"><span>类的主动使用和被动使用</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#三、运行时数据区概述及线程"><span>三、运行时数据区概述及线程</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-运行时数据区内部结构"><span>1.运行时数据区内部结构</span></a></li><li><a class="is-flex is-mobile" href="#2-线程"><span>2.线程</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#四、程序计数器"><span>四、程序计数器</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-Program-Counter-Register介绍"><span>1.Program Counter Register介绍</span></a></li><li><a class="is-flex is-mobile" href="#2-程序示例"><span>2.程序示例</span></a></li><li><a class="is-flex is-mobile" href="#2-PC寄存器为什么会被设定为线程私有"><span>(2)PC寄存器为什么会被设定为线程私有?</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#五、虚拟机栈"><span>五、虚拟机栈</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#・栈的特点（优点）"><span>・栈的特点（优点）</span></a></li><li><a class="is-flex is-mobile" href="#设置栈大小"><span>设置栈大小</span></a></li><li><a class="is-flex is-mobile" href="#3-栈存储单位"><span>3.栈存储单位</span></a></li><li><a class="is-flex is-mobile" href="#16-一些附加信息-略"><span>16.一些附加信息(略)</span></a></li></ul><li><a class="is-flex is-mobile" href="#17-面试题"><span>17.面试题</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#六、本地方法接口"><span>六、本地方法接口</span></a></li><li><a class="is-flex is-mobile" href="#七、本地方法栈"><span>七、本地方法栈</span></a></li><li><a class="is-flex is-mobile" href="#八、堆"><span>八、堆</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-堆的核心概述"><span>1.堆的核心概述</span></a></li><li><a class="is-flex is-mobile" href="#2-堆的细分内存结构"><span>2.堆的细分内存结构</span></a></li><li><a class="is-flex is-mobile" href="#3-设置堆内存大小与OOM"><span>3.设置堆内存大小与OOM</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-设置堆内存"><span>1.设置堆内存</span></a></li><li><a class="is-flex is-mobile" href="#运行程序查看-jvisualvm"><span>运行程序查看 jvisualvm</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#4-年轻代与老年代"><span>4.年轻代与老年代</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#参数设置："><span>参数设置：</span></a></li><li><a class="is-flex is-mobile" href="#对象流程："><span>对象流程：</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-对象分配过程"><span>5.对象分配过程</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#九、方法区"><span>九、方法区</span></a></li><li><a class="is-flex is-mobile" href="#十、直接内存"><span>十、直接内存</span></a></li><li><a class="is-flex is-mobile" href="#十一、执行引擎"><span>十一、执行引擎</span></a></li><li><a class="is-flex is-mobile" href="#十二、StringTable"><span>十二、StringTable</span></a></li><li><a class="is-flex is-mobile" href="#十三、垃圾回收概述"><span>十三、垃圾回收概述</span></a></li><li><a class="is-flex is-mobile" href="#十四、垃圾回收相关算法"><span>十四、垃圾回收相关算法</span></a></li><li><a class="is-flex is-mobile" href="#十五、垃圾回收相关概念"><span>十五、垃圾回收相关概念</span></a></li><li><a class="is-flex is-mobile" href="#十六、垃圾回收器"><span>十六、垃圾回收器</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://gitee.com/mychimei/picture/raw/master/微信图片_20210131173244.jpg" alt="魑魅先生"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">魑魅先生</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>浙江-杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrDemonlxl" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrDemonlxl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/MrDemonlxl"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/714416426@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Next" href="https://mrdemonlxl.github.io"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzI5NDc0MDg1Mg==#wechat_redirect"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.jianshu.com/u/7b24074baf6a" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span><span class="level-right"><span class="level-item tag">www.jianshu.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/qq_37862970" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/11/26/Draft/2021/Markdown%20%E5%AD%A6%E4%B9%A0/"><img src="https://gitee.com/mychimei/picture/raw/master/webp1.png" alt="Markdown 学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-11-26T06:03:51.656Z">2021-11-26</time></p><p class="title"><a href="/2021/11/26/Draft/2021/Markdown%20%E5%AD%A6%E4%B9%A0/">Markdown 学习</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a> / <a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/">主题工具</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/11/10/Draft/2021/JVM%20%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/"><img src="https://gitee.com/mychimei/picture/raw/master/39go6v.jpg" alt="JVM 与上层技术"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-11-10T14:10:43.000Z">2021-11-10</time></p><p class="title"><a href="/2021/11/10/Draft/2021/JVM%20%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/">JVM 与上层技术</a></p><p class="categories"><a href="/categories/%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/">底层学习</a> / <a href="/categories/%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/JVM-%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/">JVM 与上层技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/17/Draft/2021/%E5%B7%A5%E5%85%B7%E7%AF%87/"><img src="https://gitee.com/mychimei/picture/raw/master/webp.png" alt="工具篇"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-08-17T12:03:22.957Z">2021-08-17</time></p><p class="title"><a href="/2021/08/17/Draft/2021/%E5%B7%A5%E5%85%B7%E7%AF%87/">工具篇</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a> / <a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/">主题工具</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/07/22/Draft/2021/%E8%B5%84%E6%BA%90%E7%AF%87/"><img src="https://gitee.com/mychimei/picture/raw/master/webp3.png" alt="魑魅先生 | 资源篇"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-07-22T06:27:10.475Z">2021-07-22</time></p><p class="title"><a href="/2021/07/22/Draft/2021/%E8%B5%84%E6%BA%90%E7%AF%87/">魑魅先生 | 资源篇</a></p><p class="categories"><a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/">工具教程</a> / <a href="/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E8%B5%84%E6%BA%90%E7%AF%87/">资源篇</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/07/06/Draft/2021/Python3%E5%AD%A6%E4%B9%A0/"><img src="https://gitee.com/mychimei/picture/raw/master/webp1.png" alt="Python 学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-07-06T06:11:46.247Z">2021-07-06</time></p><p class="title"><a href="/2021/07/06/Draft/2021/Python3%E5%AD%A6%E4%B9%A0/">Python 学习</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%AD%A6%E4%B9%A0/">Python学习</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/BUG%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">BUG记录</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/BUG%E8%AE%B0%E5%BD%95/BUG/"><span class="level-start"><span class="level-item">BUG</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/English/"><span class="level-start"><span class="level-item">English</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/English/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">程序员英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">JAVA应用</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%BA%94%E7%94%A8/%E4%B8%9A%E5%8A%A1%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">业务技术</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Spring/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Dubbo/"><span class="level-start"><span class="level-item">Dubbo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"><span class="tag">工具教程</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BUG/"><span class="tag">BUG</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dubbo/"><span class="tag">Dubbo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NO-GAME-NO-LIFE/"><span class="tag">NO GAME NO LIFE</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python%E5%AD%A6%E4%B9%A0/"><span class="tag">Python学习</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Software-Engineer/"><span class="tag">Software Engineer</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"><span class="tag">书影音</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"><span class="tag">信息系统项目管理师</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/"><span class="tag">信息系统项目管理师论文模板</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%81%A5%E8%BA%AB%E5%A4%96%E5%9E%8B/"><span class="tag">健身外型</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">学习方法</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/"><span class="tag">底层学习</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%85%E5%8A%9E/"><span class="tag">待办</span><span class="tag is-grey-lightest">1</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=mrdemonlxlFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="mrdemonlxlFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://gitee.com/mychimei/picture/raw/master/彩色logo.png" alt="魑魅先生" height="28"></a><p class="size-small"><span>&copy; 2021 魑魅先生</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/02/18 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="3071252637" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('20ef8321698ab8c0c37b','4faa4daae14b55afd2ed357fba92d1e9c7c3f729','MrDemonlxl','MrDemonlxl.github.io',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('20ef8321698ab8c0c37b','4faa4daae14b55afd2ed357fba92d1e9c7c3f729','MrDemonlxl','MrDemonlxl.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>