{"pages":[{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://mrdemonlxl.github.io/images/avatar.jpg 网站名称：魑魅先生 网站地址：https://mrdemonlxl.github.io/ 网站简介：Java全栈开发，技术分享，程序员的生活分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"【个人简介】 分享不知出处的一段话： &quot;你所有的烦恼都在于你想得太多，而做得太少。&quot; 无论多么精美浩瀚的绝世计划，都应该点点滴滴赋予行动。 在这里你可以得到什么? 😎 效率的种种利器！ 😎 Java全栈技术学习！ 😎 代码之外的丰富生活！ 【总内容导图】 【关于魑魅先生】 【动漫人物介绍】 魑魅魍魉（chī mèi wǎng liǎng），形形色色妖魔鬼怪，现通指坏人。而魑魅先生乃妖中之首，掌控妖魔万物，专克魑魅魍魉，其面容清秀，千变万化，善学好思矣。其间见霸戈【BUG】，祸害人世间，便习编程术，从此不归路。 绘画作者: @YYu 【联系方式】 如有任何交流需求，请添加个人微信或个人公众号 添加前请备注来由。(๑‾ ꇴ ‾๑) 微信扫码或点击链接关注我哦︿(￣︶￣)︿ 凡事预则立，不预则废。 计划 2021-PLANS DAY 读书 每日算法 每日英语 理财，记账 WEEK 绘画 吉他 运动两次 练字 MONTH 总结 YEAR 熟练一个以上技能 目标 2021-GOALS 读书 《社会心理学》 《大问题：简明哲学导论》 《局外人》 《三体》 《我是猫》 专业 设计模式代码Demo 网络 JVM VUE项目 Linux 音乐 吉他谱扒谱学习 运动 画画 时间轴记录 本站推荐索引 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享","link":"/about/index.html"},{"title":"","text":"🎈🎈摄影-平面设计-绘画欣赏🎈🎈 每天看一点，审美高一点 😊薇薇安·迈尔😊 ​ 薇薇安·迈尔（Vivian Maier），1926年2月1日出生于美国纽约，美国业余街头摄影师、家庭保姆。薇薇安是法国人后裔，出生在纽约，但在法国长大，后回到美国先后生活在纽约和芝加哥，她一生拍摄了超过10万张照片。2007年，芝加哥当地历史学家约翰·马鲁夫发现了她的大量底片并开始整理，此后她的作品登上美国以至意大利、阿根廷和英国等地的报纸。2009年4月21日病逝于芝加哥。2010年，薇薇安的作品开始在芝加哥进行展出，成为摄影圈中热议的人物，并被认可为美国当代最重要的街头摄影师之一。 图片部分搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"好问则裕，自用则小。——《尚书·仲虺之诰》","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"碎碎念树洞 tips：github登录后按时间正序查看、可点赞加❤️「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '20ef8321698ab8c0c37b', clientSecret: '237515b7faa3e1097f2980762f772c6f02dbcbbb', id: '666666', repo: 'MrDemonlxl.github.io', owner: 'MrDemonlxl', admin: \"MrDemonlxl\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"个人学习食用，如有推荐请留言歌单或歌曲链接。点击左下角箭头可全局播放哦 - 🤲😎 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"BUG","text":"一次相见，绝不再见 BUG分类解决记录，常见排查方法，常见避免方法总结。","link":"/2021/02/24/Draft/2021/BUG/"},{"title":"魑魅先生 | 业务技术","text":"所有的技术都是为了更好的解决业务 JAVA应用（菜鸟一站），栏目下有： 文件上传下载解析到数据库 网络通信 加密解密 缓存 外部接口应用 工作流 代码生成 文件格式转换（word--》pdf） 数据格式转换 工具类合集 分页 跨域 单点登录 外发接口规范token验证 支付 短信 目录可参考kuangstudy 文件上传下载 相关对象： 12MultipartFile 文件路径： 1HttpServletRequest req Servlet获取当前项目的上下文路径（web文件下的路径）： 1req.getContextPath() Servlet获取当前项目的上下文的绝对路径（web文件下的路径）： 1req.getServletContext().getRealPath(); 获取Java程序中的resources文件路径： 1Resources.getResourceAsStream() 前后端交互： 跨域 什么情况会跨域 同一协议， 如http或https 同一IP地址, 如127.0.0.1 同一端口, 如8080 以上三个条件中有一个条件不同就会产生跨域问题。 解决方案 前端解决方案 使用JSONP方式实现跨域调用； 使用NodeJS服务器做为服务代理，前端发起请求到NodeJS服务器， NodeJS服务器代理转发请求到后端服务器； 后端解决方案 nginx反向代理解决跨域 服务端设置Response Header(响应头部)的Access-Control-Allow-Origin 在需要跨域访问的类和方法中设置允许跨域访问（如Spring中使用@CrossOrigin注解）； 继承使用Spring Web的CorsFilter（适用于Spring MVC、Spring Boot） 实现WebMvcConfigurer接口（适用于Spring Boot） WebService 简介 跨编程语言和跨操作系统平台的远程调用技术 原理 XML,SOAP和WSDL就是构成WebService平台的三大技术 。 WebService采用Http协议来在客户端和服务端之间传输数据。WebService使用XML来封装数据，XML主要的优点在于它是跨平台的。 WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议规定的。 WebService服务器端首先要通过一个WSDL文件来说明自己有什么服务可以对外调用。简单的说，WSDL就像是一个说明书，用于描述WebService及其方法、参数和返回值。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 RESTful 简介","link":"/2021/03/01/Draft/2021/JAVA%E5%BA%94%E7%94%A8/"},{"title":"MYSQL优化","text":"MySql知识及优化 相关资源：bili视频、 Linux下RPM版MYSQL安装、启停 P32.MySQL启动问题、配置文件、编码问题 MYSQL分层、存储引擎 连接层（提供与客户端连接的服务） 服务层（提供各种用户使用的接口，提供SQL优化器【MySQL Query Optimizer】）） 引擎层（提供各种存储数据的方式【InnoDB：事物优先，适合高并发，行锁；MyISAM：性能优先，表锁】） show engines; 显示支持引擎 +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ show variables like ‘%storage_engine%’; 查看当前使用引擎 12345678-- 指定数据库引擎create table tb(​ id int(4) auto_increment,​ name varchar(5),​ dept varchar(5),​ primary key(id))ENGINE=MyISAM AUTO_INCREMENT=1DEFAULT CHARSET=utf-8 存储层（存储数据） P54SQL解析过程、索引、B树 sql优化： 原因：性能低，执行或等待时间太长，SQL语句欠佳（连接查询）、索引失效、服务器参数设置不对 SQL编写过程与解析过程： 编写:select dinstinct ..from …join ..on ..where ..group by ..having ..order by ..limit 解析:form ..on ..join ..where ..group vy ..having ..select dinstinct ..order by limit.. 索引 简介 sql优化主要是优化索引，索引（index）相当于书的目录。索引是数据结构（默认B树【小左大右】） 优点 提高查询效率（降低IO、CPU使用率） 缺点 索引本身很大（可以存放在内存/硬盘） 索引不是所有情况都适用：少量数据，频繁更新字段，很少使用的字段 索引会降低增删改查效率 分类 单值索引：单字段 唯一索引：不能重复 主键索引：不能重复，不能为null，主键默认是主键索引 复合索引：相当于二级目录（name，age） 创建索引 方式一 create 索引类型 索引名 on 表（字段） 单值索引：create index dept_index on tb(dept); 唯一索引：create unique index name-index on tb(name) 复合索引：create index dept_name_index on tb(dept,name); 方式二 alter table 表名 add 索引类型 索引名（字段） 单值索引：alter table tb add index dept_index(dept); 唯一索引：alter table tb add unique index name-index(name) 复合索引：alter table tb add index dept_name_index(dept,name); 删除索引 drop index 索引名 on 表名 查询索引 show index from 表名\\G P65.B树与索引 P76.SQL优化准备 P87.explain中的id、table P98.type级别详解 P109.索引类型及逐步优化、key_len计算方法 P1110.ref、rows、usingFilesort P1211.Extra字段 P1312优化示例 P1413.单表优化及总结 P1514.多表优化及避免索引失效原则1 P1615避免索引失效原则2 P1716常见优化方法及慢查询SQL排查 P1817慢查询阀值和mysqldumpslow工具 P1918模拟并通过profiles分析海量数据 P2019全局查询日志 P2120锁机制详解 P2221写锁示例与MyISAM模式特征 P2322表锁情况分析及行锁解析 P2423行锁的注意事项及使用情况分析 P2524查询行锁 命令集合 mysql -uroot -p 登录 show engines; 显示支持引擎 show variables like ‘%storage_engine%’; 查看当前使用引擎 12345678-- 指定数据库引擎create table tb(​ id int(4) auto_increment,​ name varchar(5),​ dept varchar(5),​ primary key(id))ENGINE=MyISAM AUTO_INCREMENT=1DEFAULT CHARSET=utf-8 MySQL基础","link":"/2022/02/24/Draft/2021/MYSQL%E4%BC%98%E5%8C%96/"},{"title":"Markdown 学习","text":"改变颜色，内嵌 HTML 标签 Markdown 学习 Markdown作为自媒体人非常方便的一个工具，可以再各大自媒体网站通用，实现一篇多发的效果。其语法简单，几乎可以抛弃鼠标，生成一切样式。 Markdown 学习 格式 首行缩进&amp;emsp;&amp;emsp; 导图 图 状态转移图 stateDiagram %% 单程生命周期起点是实心圆，终点是同心圆，内圆为实心。 %%这个例子包含是3个状态Still, Moving 和 Crash. 从Still状态可以转移到Moving，从Moving可以转移到Still 或者 Crash。不能从Still转移到Crash [*] --> Still Still --> [*] Still --> Moving: A transition note right of Moving Moving可以转移到Still或者Crash end note Moving --> Still Moving --> Crash Crash --> [*] 类图 classDiagram class Duck{ -String beakColor - double weight +swim() +quack() #count() +getPrice(count) double +someAbstractMethod() * -someStaticMethod() $ } class Shape{ %% This whole line is a comment classDiagram class Shape noOfVertices draw() } class Color{ RED BLUE GREEN WHITE BLACK } class Relation{ } classK ..> classL : 依赖关系 classA --|> classB : 继承关系（泛化） classM ..|> classN : 实现关系 classG --> classH : 关联关系 classE --o classF : 聚合关系 classC --* classD : 组合关系 Customer \"1\" --> \"*\" Ticket Student \"1\" --> \"1..*\" Course Galaxy --> \"many\" Star : Contains Sky \"1\"--> \"1\" Sun Parent \"1\" -- \"0..2\" Children Person \"1\" -- \"2\" Eyes 饼图 pie title Pie Chart \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 \"Cows\" : 150 渲染效果 graph LR id1(Start)-->id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px; style id2 fill:#f00,stroke:#000,stroke-width:2px,stroke-dasharray:5,5; 基础fontawesome支持 graph TD B[\"fa:fa-twitter for peace\"] B-->C[fa:fa-ban forbidden] B-->D(fa:fa-spinner); B-->E(A fa:fa-camerra-retro perhaps?); 连线 graph TD A1==TEXT===B1 A2-->|text|B2 A3..-B3 节点形状 graph TD B[bname] C(cname) D((dname)) E>ename] F{fname} 甘特图 关键词说明： title—标题 dateFormat—日期格式 section—模块 Completed—已经完成 Active—当前正在进行 Future—后续待处理 crit—关键阶段 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d future task : des3, after des2, 5d future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and json :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to ,mermaid :1d 流程图 graph TD A[方形] -->B(圆角) B --> C{条件a} C -->|a=1| D[结果1] C -->|a=2| E[结果2] F[竖向流程图] 时序图示例 123456789Title:时序图示例客户端-&gt;服务端: 我想找你拿下数据 SYN服务端--&gt;客户端: 我收到你的请求啦 ACK+SYN客户端-&gt;&gt;服务端: 我收到你的确认啦，我们开始通信吧 ACKNote right of 服务端: 我是一个服务端Note left of 客户端: 我是一个客户端Note over 服务端,客户端: TCP 三次握手participant 观察者 公式 $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\ \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\ \\end{vmatrix} ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$ 表格 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 代码 123456hello!--- 分割线+ [ ] 勾选框[内容文字](#标题) 页内跳转[内容文字](跳转目标文件的相对路径) 脚注 文字内容 [1] todo列表 读书 《》 专业 （设计模式代码Demo， 网络， JVM， VUE项目， Linux） 音乐 吉他谱扒谱学习 运动 画画 其他 emoji【外可访】，Typora 快捷键WIN+。 🎈🎈 🤲 😎 inserted =&gt; inserted 29th =&gt; 29th H20 =&gt; H2O basic footnote[1:1] here is an inline footnote[^2](inline footnote) and another one[2] and another one[3] footnote content The HTML specification is maintained by the W3C. flowchat st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something…|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options); basic footnote content ↩︎ ↩︎ paragraph ↩︎ footnote content with some markdown ↩︎","link":"/2021/05/28/Draft/2021/Markdown%20%E5%AD%A6%E4%B9%A0/"},{"title":"博客模板","text":"4630436162ade97ba2718b7d0c4b3b631d1cea453764294116f53c62984a56ccee1694c14ccb64fb54f8c30202167de89f7cf608014a104c10a21a4f1d77a64727bde928bfb8eb6078a4a923c466f0bcea3207c4a47cce2765396cf8004ee68a14e8e23c956c9acb4311d193a0952e02bbbbbc6468731b893359ee3df3be2d38216a3e3de5da7dd19fb7c2ce287eab5d088144ecc29ff0ff182aec2e83cb1a6fa941d3e6baa5107e5c45c08da4c6d8017c96803cc7ea4b73b8a2c188c8e3c71f17ab5d497305fb4acb167834b1a7ccc698ec42fc97118de40d781a775892bb78aa1a80d3ba0c6d680385730e6898143e4ec54811381b76f1eefa9f6ae7acb0548c35a332d8b95d8dc348768c06d6fe758830973253175d9eb525fffb134cdd831582a8b0e10686371a8a85547fd67a53dfdd61284f21b9b17854457340a63bbdef5ed48628ff89004a68635efd673e6e00571d1541f299377b85c92a017c52e4aa1b84d0c408c73fd63363001963dd6e917bd1fe88802e84e734fce4fad8a50ad8b1f0c71fc3a57c8fc774ea7a3a3e75923d63a924fad10d03eba3153d20f2b157e108653a975a3c639af2823eb7ea2052706e9d6b4090123dab7bf1f9baa12fc186b8afc3d1ecb8f17fc558cc99ef4ad43bbc0685871a12e9a0ddb00bd653b337f95c5288a942823fbe21957c67721838e8b4d716ce347e7d8f1d6a05c8b893f2539b4942af3426e3ee44fa37373052980a53405ada27f82e2664213a1313d67ac2fe4e89eeafa723fa2d4a15aa3863a3fa0f2a886e55b0d96b8f8a46e5fb0962f4227ab3757c761fe381180ddff553c9db590d2aa64336b82695902cd7454b4d0ea155ac89a9c737d718b2440b3e96607f85af06a4b0e0bdce394f6d8e74ad4af50bb0aac19c6ca07605b5ac99c4d87ebf030313b667008a160217bc0c654586127719af458f9fda0fdd809ba51d5cce5d85a05c5e78be8814fc211e26a6fd26f8bfe2c7cb32381a79e9ebe2d30720d9c8066a5ef0f06c54b42af2d22ee5f1638d60c02bfce0ef4bf7624c2f80330dbffd6bc95ec4f121b616462feec75530d3a2b28775d9c2e702440e8a7ee80106bb9600123fd8f0bb2c652fd220b1dca2fd2f5b88c2def45ec0c311df84d5b5f6a1e83f223b4bcab2277a6da766e0e24decd0b922f1592182e5ae643807073ac7659156b681166e59505187438aed5df76b232eba8087f559e7dc229947e51b36f7120167c80dc81ceb5b73bec4ff092268af8ac6301b0b3057730748bc1f88a15394e78cc2acdcc57c2ce6ec1086a7df784f9c37e142c05632352cc5e7eca6c2c0930404ad0504ffc82168be51333126d87cb2982837901ca9c978f32d58af46464123bb51c12bbd26cfb085f9b14981f640377e5e9115ced751a191b5af3dd11b38238feb06bc44ecd133e799d5e58e4ac3804519b4657129c87f12d389937fc7385a79ad86d708aaf7dfe96f34f1beed6479d3148d9f926223e7fbc4ed0d41ba0f233d94f8cf628211ca846886afe2358a9bc829d915bc1b279e1af4bff8450d9b63ea0a45f78903c220aeaebe630f15c928f86033665622f78be713531c3134eb95892555a8974f0088513762b36fa886d198fec9aa2a51d85d985efefa71a8a0f8a0588e3ab8302b7438b9b441aa674225e704c4ae49cb9cdb98d84672d0e91fb6c65a9b6668ab3b8eefee278e97de9c7148ff1be333729e7a310796fd14bb2b463eaa5c8e5596035cbbab9f15b9068a693cc78ba21c5e8eb48e6ce57679b074f3f90b89614b30b581cc27561676ac5dca08abf36ad9223f70f9e47a8a1bce8e1097e19d87db7ec274cd5318c6f0bb7af52d7d5d09c62589eccceda1865119f06c487af4d27e41feb722b89af36ded58c7ad1aa4540af529719867074ac3a1dd6b830bca62351f65966dd3e892668dcd501322bb1f3f67738e342e1cb6070d84ad3b04e9191114d6c22069c04a881865f5d952157c70fd7fc1c8b892e999bb2efdcf8cbe1172226023fa898064d94fda843012607f274802431e30400a874625e8089669acf35f7b2622aab406a4422db4532c515e3f98835c0960ff1ef4dbce6643cb071f53b98a314c46224ce013f25b7e3402b2f84bfb872493ef78fc657770bda86dc5eb6eb6c489c6688989e22a2847747f255d45778b7a2ea10990b3e5cb73dd56684bc7563ee5bac6696c6beacae307ac9eb0c20df6790adf92014b5e05a6c3378fa5c77b28cbb3e33ae8b5612e4b4dd8e090eabf0d1020ab055fb32852e50f65fd348c4747972db935a31d116cf967f10936efbb8fc3867c2aacd8b7bdce2f65e095cc6526783d9a6a6beac3d35dee9edbea12d850909917d78427b4c7f475179df5c87881b5b6af176baf19711478a94e20f05ca6c4421151c587f946dae480d1c251b7dd9d10febfa51c0a2f1fa2de05251a75011ef6c0bd9b5545f59518e75c867533a4af2f5897344fac3b7a6d0385d3410106580236d6a8193a03e8db60f9b7b32b23b35e7b30f1699b0c9575ae068c365aca4ab445ba7428f77103cc7b04b2107058a9effcb5213fd5ebae7ae98c048d7ca6faf160bb753b4243952ecf7b27c00c6724259b4d7ed85584adc557778809ba9ddc4c2013343f325e6b99f18ac9a6d0c46d24b4134ea37fc6828ce685337db620695cd6bf98002f9e21d191cf41e04707f056ed153b461fab6722e542a9d6241b7dca2041e9219866a31a21c93c7174febff948bd8bbe299014f0ee0768baa4002731e062d4786e0cf60b9775106fcba85b2501de9c20370c0bb4701d49ca1192a1992f0cd46bb5130d234fd201816c6d2801cc830b2659c85232dc049ccd64bf66f66cf39646731a90eee8ed5b3797318009eb91970c76f8e124f53d1cc1f440f122fb4330a59f07b8993c90bf7af38e6f20d7c18970c7b9ed35735d01a897af13ae850d69a2a54f394ef479b08dbe90b5f9c29c88c504648837f5db1a180aad667e0e1c167add754f27488974a2300b9650c233788089dfd82348d13a74276635d2941ce787121eabcb7e2bfb07aebf352532a79661e38f409f4a1b8d7113d76166903e4016d31ea576a2f58b47d0715f15d0cf87376acc368b9c5dffc515f2cdce95bf110153b89ffe752894ba002ff4f8af62a1d89a3d4a0d71fbf637527854bfd65921cde38376790f73754623f93633117b85678eac05225cada3de0c1c16a836d4c57c7ba909a3eaf8c67dcf624fc8934318f136d6a93eba84afb3a20cfcc83fd1859ad85f4e2d80f80002632a163cf4597fecfc36f6d3638b6f6e46f37c10423e421cc55e5d287027fcb36171651aff1821dcf3c579aece1b8e3b09feee7fe53c990feb162d172ae0a5c411e580f663ea1e78f3fdb3d44226c3d6a23595559d62360320be1d084e449c0c1bde00180cc8a370d8653565473ce02bae5a83b8d2a82e6017c9cd69cf11da248518252a0edf29f45afcea1c249ef019ac3ac91f3952462165bff82aa585068ba44a70b6ca4f1a20540a5f89e39ca5b6eafc4e11ef78bebf10f86a19533b37476e416b0adab58266651fa652dd0f1d10e33e1c1f2e3437ab1aa9dae8badd85274054a5f3a65179214a47e0745c8a02765260ac9b98255a53cc605ade136d7afc72082a291ee899118f8ab9b58a1d7608d7b156a170d5986091031492f049a79f10d327637c1665c28e3301e37ca8a5d539ae45e15f88125644f5620086acea103b771a123eeb1d9c3e875ca4b434ebcb2d135dc36b987361942b70fb2b2a2434a60e1e1b9f262060d4b6313b0300f6f2868f5ba9fdb4bddd6e07e6a7893a43ecb8ff7ae7b50abcf0dd021d6bf61c3653eb618b2949c5728b25228888846dd9ed637c4a5732827a39bb1b58ea45a70ecab8ff4a846befd2ddf178de327c9aa7acb04fd44db30b34dc4b8704686cecb3bf4b55c0f82dc463681b72d539a01dff2522da4929c27fe5dd4a916714dd06a047397eb9e6e2ac3fd7b7c9c6cd7d2a303618b38ce5ae49dcf1bc4467534f2cf028a72413e1702577bee4cc86bdec83d9e238ebd672f0b3ec61c3bd83a1f0f292b2acfcc08b3f136ca5b9413716eab68f85ee549c291a68231e4a9bf21a18ec27cd1a52913843d887879bde9d93d99ad0afb958efd601bf30ab9e8c04b009f7e0f00984c3a686e4f8fedae7f1064ab9025beef0da3b92c03f3ac75c0d3ba256cd8a9b82dbb13e84f992339739e982180aaeabb4dbc7e2fd9bb75aef5f4a80594e026f895e91b1dd6edd9096904ad1ead337eaed65ba4a1db60429ea0b1f0f6cb118ad625ee52eb2c73a28fc004802437492eab31d1850a754aeccd9bf74c684a504babdd62d82ca07483c0b668c72028a9382991ba0a4b66fdb5392aac4c40174c3a116b9e741b8809fd2f91fd6428476cfe5c0ff79e96ddd27927f40cf436f77095a7abd3fc97c4e38107b0ea0fbd93f3697d284f0814a12a9ce043a78171e60f4147c27492101cf5cc4aa127ed950a7ba8685c7db9dbf05a94d2adc752958290f732870af71e023884b3d8e59a7448ea06b3fc22b6c220079ccf0db471f404c8d4d5877dccfca3adb18986a823a85e3469b4d2ec9adfaaee39bae8ce09674e13d153dbb225d8d4656f68d4b83cdea449b0b00264c19bdfad5663d5728aedb7018dd4954be07ee212c0548375fa28da21481ac1d1a8399da45b6ffaf4c4fc0d0594e6f711d06c433f88dd0078659b74731db1aa564516ea71c3372b6e6e0b73dfa8255671a704424ced937123c9dc91346996eb0e6d455239a057e9f3f8e79ce171e162ac95d9c1ac4b293becf0b18f31aae2dd242ecc3c6cfd544e3f6671f059c5a3d8370acaf4ff192107dfa9868c2b03f78caa5c9ff8ebc460dc48fa21521997077d2301f1afcd572a9d21ae55ca8ef02f995dec3608b844ee7c0b40b8c48ca3393d2e7625805803ed97fa8b62d376d2ae6933add5523678239c0650ba1ee5ab144705ea720b97490c26078fe389ee03310c467842ff637d9b9115b42a1e14b51ce5496ea8cbfaa1def81154bdb0f65fb70b21b6c77537a48d68a818d7fe9660f37ca19c2d9ca09e3e6ea599011bb4e364a279dc5b14c58de8bf12250e650b1be3fcb9ce9105d03a29d395a40d2685ffde64e215842887f79c3de3e58408ab3e76729c27bfca5ebc724a6a357f11d36b2e2faea38774a233a5bb97843cf32c06fc9f1bd53e2ba5dbdeefbbd4e4aa4736d4722ac9ff93cb6e34c581c0e409ae643012ce37f492b0bf2d297e35c6d37817101d278f12f6675e1839d9672a50513a044d6cb640ada613c58147e8590bdc5b57857802cb1f1825e4a090921d0f6fd8cb4e3492b94c54d795e05888cd3fda67e001008f742790635da26de080cad71f7eb60d002c0438991048dcb85982deb7824714cb5bea2b833542e117c6c9639f081f52d28916e968556a4ba7882ecec96182ecabf784de2cae871e95fb3bb6c1e3a1851c2db58709719beef807ad132f146a6f8b1ba198cb0e15b093313fc0c56edcd4db59389a72a32c64876bee4991fad98e252f31c529f3bc02dea77d81edbc52a57558ada9550e4659422695aadfe82e987b08be35827403089a6d9a695f1a168a5864c6a939e9011b19fe4b08be24f75cefed39db34f368c226e98a7f582b7ce652cee6860fc15e48f421a5d82be7fa14e2ca9a98604c835cf0afccfe0d1cdcc16ffa52d05074981de0d33810cb41a7a4cdabed3e95c568466a97e402401af34e0be8c450e1c93256e4962c6696bf8055e45fde8c4c59496b293a53ad6965ea3b3e477b2352fba4f88d45bedb5605f9d9e8953f43260380cbd7f5f3fa5ac37f463a034b19ab8944edd62c7dbc3bd4ff5f483d32a1ed39cf5725882e57e5c53357fa998827894cc08f9a015b2470ffcb0a54d765e9a2aa3f74eb0cea6cbaf8da687c187c4528e441eba7e918a10ec93fd5b5d6eb248a7e7453ed0a782b8fee1cbbcdb6bd098a1782517ecc0653f02a1231d01f975082d039f6a5a43c2ec283c071f22714846169fb4beeb20bb92f90a748b6df63084bf90f52de12e7a9dc3168d9c5e58267c2afe4fae02296f54173fd96799a9c9364bc383b933e3dae3a8c3ef6f5c3b0b8a589a2384721730584e89b2e97e43eef13e24b2f5b559968e86da60d318fb9b517b31d12eebc988372d7a6b46749456c65b8afd4705f3ca78251f92b95c196c0d4724a480cbc260a477c06b24076bf30f9bae72cbd53949d760589272599a691ec639677a282a6961c5ae3ea3e8e47e1d5ef9332bc6ca4ceb6d4a7bcf1f72c6b19b5745cb6da78ba4e2f500fb865a6d5fc5b59289990448771956ff616bca023bed91e7303dc6f11702e7044c2db3fc8046a654a1fdd01fef715dec2359f9a0be5a0712c25afcd6a4cfcb0a7bad064e7d8c155e8ec1e80b3d13db8f826d3ad1f2072f6935c62c645778491f581522221eb54f161166d8ddffe273db3b7572fc146c98e8ef5421c16df57e847a45cc66a13ba9c494144ff28ddbb91c61015479df40dbb551acf97be82895cbdf37773259a20442543fb830036ca326808a212f043578cc4231f335767506f9d3aa9dc7e13646a892aee9e94f56b9fd05a85cabcff5b980fb180313d68b6c2495737413a3a1acc8f22f6205d02a3bf32440d68d379ba332f1c2c0ee7c08a24fc6e8b619cefa7b6208047a18c48f93c7242d058785068d334ec47e2ea2b431fd371bf5112f0dd38a0fec803706569bb6cda8be3fd076f1d7e0911ac700a727cf11e74a99aaa7d446f56057619393a75a8478b056889074b91a4ce8fcb868e90552d3b3c65da71f9277b3df5a9a6de07dde219e6d91296ec2497ed27b8ce1ec964e7962e469e4a8a526b52219c05f93272e6ac6dbca6fb1d76787eb95e43cfae3c52ddc08e29c267639e6445dbbc4bc8ea1e407f01f2051f98423d7c1afd1cf6c8de8280a 嗨，请准确无误地输入密码查看哟！","link":"/2021/01/19/Draft/2021/Hexo%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B/"},{"title":"NO GAME NO LIFE","text":"游戏人生 🎈🎈🎈😎 吉他扒谱--数绘--英语--摄影 😎🎈🎈🎈 目前学习路线内容 优先等级 吉他乐理，扒谱 😎😎😎😎😎 数绘 😎😎😎😎😎 英语 😎😎😎😎 摄影 😎😎😎😎 运动 😎😎😎😎 自媒体 😎😎😎😎 平面设计 😎😎😎😎 目前学习路线内容 优先等级 音乐 吉他，钢琴，尤克里里，拇指琴，箫，口琴，演唱，词曲 绘画 数绘 设计 平面 运动 篮球，网球 语言 英语，日语 摄影 人像，景色 自媒体 剪辑，特效 修图 办公效率工具高端操作 OFFICE","link":"/2021/02/25/Draft/2021/NO%20GAME%20NO%20LIFE/"},{"title":"Python 学习","text":"Python3学习 简介 Python is powerful... and fast; plays well with others; runs everywhere; is friendly &amp; easy to learn; is Open. Python 发展历史 Python 特点 Python 应用 工具 开发平台：PYCharm 语法基础 爬虫 应用领域： Web and Internet Development Database Access Desktop GUIs Scientific &amp; Numeric Education Network Programming Software &amp; Game Development","link":"/2021/06/10/Draft/2021/Python3%E5%AD%A6%E4%B9%A0/"},{"title":"Nginx","text":"Nginx(&quot;engine x&quot;)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。 下载 安装部署 ​ 解压后不要直接点击exe，会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以。 12345start nginx//启动服务nginx -s reload//重新加载配置并启动nginx -s stop// 快速停止nginx -s quit//完整有序的关闭nginx -t // 检查配置是否正确 配置自定义nginx.conf 指令必须以分号结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#user nobody;#==工作进程数，一般设置为cpu核心数worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events { #==最大连接数，一般设置为cpu*2048 worker_connections 1024;}http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' # '$status $body_bytes_sent &quot;$http_referer&quot; ' # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; #==客户端链接超时时间 keepalive_timeout 65; #gzip on; #当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点 server_names_hash_bucket_size 512; #server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点 #每一个请求进来确定使用哪个server由server_name确定 server { #站点监听端口 listen 8800; #站点访问域名 server_name localhost; #编码格式，避免url参数乱码 charset utf-8; #access_log logs/host.access.log main; #location用来匹配同一域名下多个URI的访问规则 #比如动态资源如何跳转，静态资源如何跳转等 #location后面跟着的/代表匹配规则 location / { #站点根目录，可以是相对路径，也可以使绝对路径 root html; #默认主页 index index.html index.htm; #转发后端站点地址，一般用于做软负载，轮询后端服务器 #proxy_pass http://10.11.12.237:8080; #拒绝请求，返回403，一般用于某些目录禁止访问 #deny all; #允许请求 #allow all; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; #重新定义或者添加发往后端服务器的请求头 #给请求头中添加客户请求主机名 proxy_set_header Host $host; #给请求头中添加客户端IP proxy_set_header X-Real-IP $remote_addr; #将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #给请求头中添加客户端的Cookie proxy_set_header Cookie $http_cookie; #将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。 proxy_redirect off; #浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。 #所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian=B 的 Cookie， #前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。 #不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下， #不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。 #设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量 #转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取 #配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域) proxy_cookie_domain localhost .testcaigou800.com; #取消当前配置级别的所有proxy_cookie_domain指令 #proxy_cookie_domain off; #与后端服务器建立连接的超时时间。一般不可能大于75秒； proxy_connect_timeout 30; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } #当需要对同一端口监听多个域名时，使用如下配置，端口相同域名不同，server_name也可以使用正则进行配置 #但要注意server过多需要手动扩大server_names_hash_bucket_size缓存区大小 server { listen 80; server_name www.abc.com; charset utf-8; location / { proxy_pass http://localhost:10001; } } server { listen 80; server_name aaa.abc.com; charset utf-8; location / { proxy_pass http://localhost:20002; } } 功能 1）反向代理 正向代理：特定情况下，代理用户访问服务器，需要用户手动的设置代理服务器的ip和端口号。 反向代理：是用来代理服务器，代理用户要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器(服务集群模式)，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。 Nginx在反向代理上，提供灵活的功能，可以根据不同的正则采用不同的转发策略，如图设置好后不同的请求就可以走不同的服务器。 2）负载均衡 负载均衡：多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 Nginx可使用的负载均衡策略有：轮询（默认）、权重、ip_hash、url_hash(第三方)、fair(第三方)。 3）动静分离 常用于前后端分离，Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理相应的请求，使整个服务器系统的性能、效率更高。 Nginx可以根据配置对不同的请求做不同转发，这是动态分离的基础。静态请求对应的静态资源可以直接放在Nginx上做缓冲，更好的做法是放在相应的缓冲服务器上。动态请求由相应的后端服务器处理。","link":"/2021/02/24/Draft/2021/Nginx/"},{"title":"Software Engineer","text":"高级全栈软件工程师养成记 GIS研发工程师，全栈Java开发工程师 🎈🎈🎈😎 TODO 😎🎈🎈🎈 设计模式 Redis 算法 目题(Java基础深入，其他面试题) Springcloud 目前学习路线内容 优先等级 设计模式 😎😎😎😎😎 Redis 😎😎😎😎😎 RabbitMQ 😎😎😎😎 数据库优化 😎😎😎😎 网络 😎😎😎😎 算法 😎😎😎😎 SpringCloud 😎😎😎😎 GIS 😎😎😎😎 Linux 😎😎😎 JVM 😎😎 Dubbo 😎😎 ElasticSearch 😎😎 Node.js 😎😎 ES6 😎😎 Docker 😎😎 分布式 😎😎 高并发 😎😎 Python 😎😎 学习内容 项目名称 详细内容 进度记录 软件工程 （微服务，分布式，高并发，多线程，性能调优，缓存，消息，搜索）其他应用服务器了解。 项目 个人博客 个人博客完成 前端 VUE，Bootstrap，JS，Html，JQuery，Ajax，Thymeleaf,Axios 后端 基础深入，代码多写 框架 框架扎实深入，SpringCloud尝试了解 数据库 Oracle基础使用，MySQL,索引，触发器，存储过程，优化（文件化，从设计到e-r图到创建），Redis,MangoDB 算法 算法机试题 设计模式 Mybatis（ 1、Builder模式5、组合模式9、迭代器模式2、工厂模式3、单例模式4、代理6、模板方法模式7、适配器模式8、装饰者模式）Spring（1.简单工厂2.工厂方法3.单例模式4.适配器模式5.装饰器模式6.代理模式7.观察者模式8.策略模式9.模版方法模式） 网络 协议 系统 Linux常用命令，JVM 工具 Git，SVN高级操作，Pageoffice 实操 机试题 中间件 RabbitMQ ElasticSearch Docker Dubbo 测试 单元测试 部署 服务器Jboss 维护 其他 Python【熟悉基础】安卓【有时间了解】 公司 springboot+mybatis+gis+vue+redis+框架+基础前后端数据交互+springcloud【有时间了解】","link":"/2021/02/25/Draft/2021/Software%20Engineer/"},{"title":"TODO","text":"FIXED 工具：时光序 流程：拟计划–》时光序—》记录 首要计划 SQL优化 Redis 网络 设计模式，算法， JVM Java多线程并发、IO、net 框架原理、分布式、中间件 MQ Dubbo SpringCloud ElasticSearch 拟计划 拟计划，分于每个月的目标 考完后补充软考笔记，每周细化记忆，项目管理对应实践 设计模式 Java工作流 Python复习 DevOps VUE视频一遍 Jenkins Nginx 系统设计（数据库，软件流程） Linux环境开发部署，熟悉shell 小计划 小计划，有空就做 爬虫了解，Python复习 国外技术网站 严格执行奖惩制度 深度学习复习 一周一思考出篇公众号文章 文件上传下载清晰化 平台开发 编程思想重点查看 Pageoffice 健身开始肚肚 周期总结 微信小程序聊天提醒机器人 Postgresql学习准备 固定计划 固定计划，每天都做 算法 英语 面题 [ ] MONTH-----六 运动三次 数码绘画一次 摄影 剪辑 公众号运营 WEEK🤲 吉他练习 DAY-2021.5.28 固定计划 [ ] MONTH-----五 项管师 MONTH-----四 运动三次 数码绘画一次 摄影 剪辑 公众号运营【粉丝引导，自媒体矩阵搭建】 RabbitMQ基础第一轮 springcloud第一轮 VUE复习一遍 WEEK🤲🤲🤲 吉他练习 运动 DAY-2021.4.15 SpringCloud【】一节 项管师基础 四节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.14 SpringCloud【】一节 项管师基础 四节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.13 SpringCloud【】一节 项管师基础 四节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.12 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 WEEK🤲🤲 吉他练习 ### DAY-2021.4.11 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 ### DAY-2021.4.8 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 ### DAY-2021.4.7 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.6 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 WEEK🤲 吉他练习 运动 DAY-2021.4.3 SpringCloud【】一节 项管师基础 两节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.2 SpringCloud【】一节 项管师基础 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.4.1 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.3.31 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.3.30 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 WEEK🤲🤲🤲🤲 吉他练习 运动 MONTH------三 运动三次 数码绘画一次 摄影 剪辑 公众号运营【粉丝引导，自媒体矩阵搭建】 RabbitMQ基础第一轮 springcloud第一轮 WEEK🤲 吉他练习 运动 WEEK🤲🤲 吉他练习 WEEK🤲🤲🤲 吉他练习 运动 WEEK🤲🤲🤲🤲 吉他练习 运动 DAY-2021.3.29 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.3.25 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.3.24 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 面题【】一题 Redis【】回忆 DAY-2021.3.23 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 虚拟机环境安装 面题【】一题 Redis【】回忆 DAY-2021.3.22 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 RabbitMQ 7节 面题【】一题 Redis【】回忆 DAY-2021.3.19 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.18 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.17 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.16 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.15 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.12 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.11 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.10 SpringCloud【】一节 设计模式【】一个 英语【中午】强制外语网站-新闻-书，100单词刷 算法【中午】一题，一知识 面题【】一题 Redis【】回忆 DAY-2021.3.9 SpringCloud 设计模式 英语【中午】强制外语网站，100单词刷 算法【中午】 面题 Redis DAY-2021.3.8 SpringCloud 设计模式 英语【中午】强制外语网站，100单词刷 算法【中午】 面题 Redis 模板 MONTH-----四 运动三次 数码绘画一次 摄影 剪辑 公众号运营 WEEK🤲🤲🤲🤲 吉他练习 运动 DAY-2021.3.9 SpringCloud【】一节 固定计划 DAY-2021.3.9 SpringCloud【】一节 固定计划 WEEK🤲🤲🤲 吉他练习 DAY-2021.3.9 SpringCloud【】一节 固定计划 WEEK🤲🤲 吉他练习 运动 DAY-2021.3.9 SpringCloud【】一节 固定计划 WEEK🤲 吉他练习 运动 DAY-2021.3.9 SpringCloud【】一节 固定计划 FIXED RECORDS 健身记录 BUG排查总结 项管师总结，周末五节课 图书馆借阅信管师书籍，周六 软考高级备考 11.10 交费成功的报考人员于5月24日10:00至28日16:00通过浙江软件考试网下载并打印考试准考证，逾期未打印准考证视为放弃考试。报考人员按准考证规定的时间、地点和要求参加考试。","link":"/2022/02/24/Draft/2021/TODO/"},{"title":"书影音","text":"记录与回忆才能让那些美好的不美好的存留脑中，阵阵回荡与发酵。 单月更新 BOOKS--OTHER 《白夜行》（东野奎吾） 《解忧杂货铺》（东野奎吾） 《许三观卖血记》（余华） 《我们仨》（杨绛） 《我的家》（巴金） 《局外人》 《小王子》 《恶意》（东野奎吾） 《摆渡人》克莱尔麦克福尔 《偷影子的人》（马克李维） 《岛上书店》（东野奎吾） 《嫌疑人X的献身》 《活着》（余华） 《穆斯林的葬礼》（霍达） 《乖，摸摸头》（大冰） 《水彩从入门到精通》（飞乐鸟） 《人，诗意的栖居》（海德格尔） 《明朝那些事》当年明月，石锐 《看见》柴静 《混血豹王》沈石溪 《狼王梦》沈石溪 《第七天》余华 《地心游记》 《目送》龙应台 《人间失格》 《别上了摄影的当》 《拍出明星范》 《人像摄影教程》 唐东平 《安徒生童话》 BOOKS--MAJOR 《深入理解Java虚拟机3》 《计算机网络自顶下下方法》 《程序员的自我修养》 1.实践出真知，通用最宝贵，最新乐于求，沟通不可无，环境影响大，切保身体好，薪酬等量级，单项求发展，声誉建品牌，不断学进步 2.英语很重要，阅读优秀项目， 《阿里巴巴开发手册》 1.所有数据库都要配置gmy_create(创建时间)、gmt_modified(更新时间)且需要自动化 MUSIC MOVIES 《银河护卫队2》 《新木乃伊》 《加勒比海盗1234》 《这个杀手不太冷》 《肖申克的救赎》 《泰坦尼克号》 《怦判心动》 《星际穿越》 《源代码》 《黑客帝国》 《曾经》 《爱丽丝的梦游仙境》 《冈仁波次》 《天空之城》 《变形金刚5》 《机器管家》 《独立日》 《幽灵行动阿尔法队》 《太空旅客》 《太空一号》 《地心引力》 《暮光之城》 《异形》 《火星救援》 《美丽人生》 《深夜食堂》 《战狼1/2》 《摆渡人》 《安德得游戏》 《十二只猴子》 《小森林》 《逆世界》 《金刚骷髅岛》 《夏洛特烦恼》 《左耳》 《钢铁骑士》 《捉妖记》 《重返20岁》 《机械师》 《攻壳机动队》 《一万公里的约定》 《生化危机全》 《谋杀似水年华》 《第九区》 《与君相恋100次》 《悟空传》 《刺客信条》 《绣春刀，修罗场》 《权利的游戏1234567》 嫌疑人X的献身 寻梦环游记 缝纫机乐队 敦刻尔克 洛丽塔 魁拔123 解忧杂货店 前任3 神奇女侠 芳华 被偷走的那五年 从你的全世界路过 分手合约 夏洛特烦恼 匆匆那年 失恋33天 海上钢琴师 公牛历险记 179小时 月球 记忆大师 黑天鹅 银翼杀手 血战钢锯岭 自杀小队 看不见的客人 二代妖精之今生有幸 比得兔 天空之眼 小萝莉的猴神大叔 弱点 阿甘正传 当幸福来敲门 硅谷123 国王的演讲 我是江小白 影 绿皮书 盗梦空间 调音师 少年派的奇幻漂流 怦然心动 霸王别姬 复仇者联盟四 蜘蛛侠平行宇宙 头号玩家 明日边缘 小时光 疯狂动物城 驯龙高手12","link":"/2021/02/24/Draft/2021/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"},{"title":"JVM 与上层技术","text":"JVM 与上层技术 JVM 与上层技术 为什么学习： 面试需要，实际应用，底层调优，向下学习 跨平台的语言 跨语言的平台 真正搞懂需要自己编写一个JVM。 Java发展 90 Sun公司Oak改名java----》 95sun正式发布Java与HotJava，首次公开亮相---》 96 JDK1.0-----》 98JDK1.2，JSP、Servlet、EJB规范，分J2EE,J2SE,J2ME------&gt; 00 HotSpot正式发布成为默认虚拟机------》 02Jdk1.4古老Classic退出舞台----》 03Scala,Groovy-----&gt; 04,JDK1.5发布改名为JavaSE5.0-----&gt; 05，JavaOne大会召开，SUN公司公开Java SE 6J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 06,SUN公司发布JRE6.0,06 JDK6,开源建立openJDK，Hotspot为其默认虚拟机 07，Clojure 08，Oracle收购BEA，得到JRockit虚拟机 09，SUN公司发布Java EE 6，Twiiter从Ruby迁移到Scala，这是平台有一次大规模运用 10，由于Oracle公司对于Java社区的不友善，因此Apache扬言将退出JCP，Oracle收购Sun，获得HotSpot 11，Oracle公司发布Java SE 7，新垃圾回收器G1 14，Oracle公司发表Java SE 8 17，Oracle公司发表Java SE 9,将G1设置为默认GC代替CMS,IBMJ9开源形成现在的OpenJ9社区 18，Oracle公司发表Java SE 10，Java SE 11发布 19，JDK12 JVM介绍 Java虚拟机JVM（Java Virtual Machine），执行字节码的虚拟计算机，二进制字节码的运行环境 特点：一次编译到处运行，自动内存管理，自动垃圾回收功能 JVM位置 ​ JVM整体结构 Java代码执行过程 JVM架构模型 反编译字节码文件：javap -v 字节码文件名.class 打印当前程序进程：jps JVM生命周期 JVM发展历程","link":"/2021/01/28/Draft/2021/jvm%E4%B8%8E%E4%B8%8A%E5%B1%82%E6%8A%80%E6%9C%AF/"},{"title":"BUG","text":"身体是革命的本钱 软件：小红书，记录心得，读书电影笔记，摄影，旅游 第一个小目标：减掉小肚肚 健身计划： 至少每天 80 个仰卧起坐 代替方案：篮球，跑步 记录： 2021.3.25 100仰卧起坐","link":"/2021/02/24/Draft/2021/%E5%81%A5%E8%BA%AB%E5%A4%96%E5%9E%8B/"},{"title":"五分钟搭建在线博客","text":"博客已成为程序员学习与输出重要一环，当你时间宝贵或者没有必要从零构建个人博客的话，一个可以进行快速搭建的静态博客就显得比较重要了。不但丰富的主题可以任你选择，各个组件还可以任你搭配。有的甚至无需服务器和域名注册，分分钟实现自己分享的小基地。 目前比较流行的开源框架有 Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll 白嫖党【无需服务器，免费域名】喜欢的无个人域名无法被百度搜索 Jekyll、Hugo、Hexo 本博客使用 Hexo 接下来开始Hexo博客快速搭建 环境准备 Github账号，新库名:用户名.github.io node.js、npm、JS、Git 安装与基础学习 图床 Gitee+PicGo 初步搭建 创建博客文件夹，shift+右键进入目录cmd 安装hexo npm install -g hexo-cli 初始化文件夹 hexo init hexo_blog 进入博客文件夹 cd E:\\my\\hexo_blog 安装博客需要的依赖文件 npm install Hexo命令 hexo cl #清理 hexo g #生成 hexo s #本地服务 hexo d #发布 测试http://locakhost:4000 或127.0.0.1:4000 初步搭建完成 Hexo相关配置 项目目录说明 _config.yml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117title: 博客名subtitle: 副标题description: 博客描述keywords: SEO搜索关键词author: 文章作者language: zh-CN #语言timezone: ''#时区# URL## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'url: http://MrDemonlxl.github.io #网址root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: '' wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: ''# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports 'mtime', 'date', 'empty'updated_option: 'mtime'# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: amazing#landscape# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/MrDemonlxl/MrDemonlxl.github.io.git branch: maincomment: #评论 type: gitalk language: zh-CN #zh-CN #Localization language key, en, zh-CN and zh-TW are currently available. owner: MrDemonlxl # (required) GitHub user name repo: MrDemonlxl.github.io # (required) GitHub repository name client_id: # (required) OAuth application client id client_secret: # (required) OAuth application client secret admin: [''] create_issue_manually: true distraction_free_mode: false has_hot_recommend: true # 是否有热门推荐 has_latest_comment: true #是否有最新评论 # 主题选择 https://hexo.io/themes/ 选择喜欢主题，下载相应主题包放入主题文件夹，进行对应主题说明配置。 # 继续学习完善 https://hexo.io/zh-cn/docs/index.html # 效果预览 https://mrdemonlxl.github.io/","link":"/2021/02/18/Draft/2021/%E4%BA%94%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BF%E5%8D%9A%E5%AE%A2/"},{"title":"如何学习一个新知识","text":"个人学习流程工具记录，如何将一个学习目标最高效率化 工具 Xmaind MarginNote Typora Anki 印象笔记 专项工具 坚果（笔记在线同步） 流程 Google 为什么学【与前代优化了什么】，学什么【框架，思维导图】，如何学【重复运用，直接背诵】，学到哪【会用即可】 资源准备 Xmaind，MarginNote，Goodnotes【思维导图，笔记】 Typora，印象笔记 导入思维导图 Markdown 笔记细化，方便整理分享 Anki 艾宾浩斯记忆稳固 结构化====》细化====》固化====》更新 方法 分类学习 重复记忆 实操运用 最高标准 笔记方法 合理计划 督促验收 网络方法 费曼学习法","link":"/2021/02/09/Draft/2021/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9F%A5%E8%AF%86/"},{"title":"博客计划","text":"博客规划，构建ing 2021-GOALS 前端栏目 Java栏目 Python栏目 每日算法栏目 设计模式栏目 网络知识栏目 音乐乐理栏目 职场经验栏目 艺术欣赏栏目 设计栏目 工具栏目 语言栏目","link":"/2021/02/09/Draft/2021/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"},{"title":"工具篇","text":"工具篇 工具篇 工欲善其事，必先利其器 编程 IDEA 电脑应用 学习 数码工具 Synergy键鼠共享工具 坚果云，文件同步工具 网站推荐 艺术 记录 时光序【备忘，提醒，TODO】","link":"/2021/05/28/Draft/2021/%E5%B7%A5%E5%85%B7%E7%AF%87/"},{"title":"魑魅先生 | 每日算法","text":"为什么学？编程的灵魂，不管什么语言都得需要。 如何学？多想多写多用 学到什么程度？实际运用 题源：Leetcode 一.基本数据结构 第一章 算法定义 在特定计算模型下，在信息处理过程中为了解决某一类问题而设计的一个指令序列。 要素： 输入：待处理的信息，即对具体问题的描述。 输出：经过处理之后得到的信息，即问题的答案。 确定性：任一算法都可以描述为由若干种基本操作组成的序列。 可行性：在相应的计算模型中，每一基本操作都可以实现，且能够在常数时间内完成。 有穷性：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。 1.2性能分析预评价 三个层次：合法程序，确定尺度度量算法效率，通过对算法设计编写效率高，能处理大规模数据的程序， 时间复杂度 T(n) 度量算法执行速度并评价其效率，算法需要多少时间才能得到结果 ==》针对不同规模的输入，算法的执行时间各是多少 ==》统一规模算法处理时间也不相同 空间复杂度 算法所需存储空间 1.3 算法复杂度及其分析 1.3.1 O(1)⎯⎯取非极端元素 1.3.2 O(logn)⎯⎯进制转换 1.3.3 O(n)⎯⎯数组求和 1.3.4 O(n2)⎯⎯起泡排序 1.3.5 O(2r)⎯⎯幂函数 1.4 计算模型 1.4.1 可解性 1.4.2 有效可解 1.4.3 下界 1.5 递归 1.5.1 线性递归 1.5.2 递归算法的复杂度分析 1.5.3 二分递归 1.5.4 多分支递归 第二章 栈与队列 栈与队列最简单基本，但也是最重要的。JVM，CPU，Java提供对应内建类， 2.1 栈 后进先出（Last-in-first-out，LIFO），比如浏览器访问记录与回退，编辑回退。 元素： 栈容量，栈顶指针，初始化 进栈push()、出栈pop()，查栈顶peek() Java java.util.Stack ：push()、pop()、peek()（功能等价于top()）、getSize()以及empty()（功能等价于isEmpty()） 应用：数组倒置，括号匹配算法， 三种实现方式 数组 链表 LinkedList 2.2 队列 先进先出（First-In-First-Out, FIFO），羽毛球筒 2.2.1 队列ADT Queue 接口 元素 队头、队尾、队尾加元素add()，队头删除元素poll(),查队头元素peek() 2.2.2 基于数组的实现 顺序数组，整体移动 循环数组， 性能分析，O(1)。 2.2.3 队列应用实例 循环分配器，Josephus 环 2.3 链表 数组长度必须固定，在空间效率及适应性方面还存在不足。 2.3.1 单链表 元素 首节点，末节点 ​ 链表的第一个和最后一个节点，分别称作链表的首节点（Head）和末节点（Tail）。末节点的特征是，其next 引用为空。如此定义的链表，称作单链表（Singly linkedlist）。 ​ 与数组类似，单链表中的元素也具有一个线性次序⎯⎯若P 的next 引用指向S，则P 就是S的直接前驱，而S 是P 的直接后继。与数组不同的是，单链表的长度不再固定，而是可以根据实际需要不断变化。如此一来，包含n 个元素的单链表只需占用O(n)空间⎯⎯这要比定长数组更为灵活。 2.4 位置 2.5 双端队列 第三章 向量、列表与序列 ​ 序列（Sequence），就是依次排列的多个对象，就是一组对象之间的后继与前驱关系，是数据结构设计的基础。两种典型的序列：向量（Vector）和列表（List）。 3.1 向量与数组 3.1.1 向量ADT 第四章 树 ​ 前面所有的数据结构根据其实现方式，可以划分为基于数组实现和基于链表实现，其各有长短，数组善查找读取，修改耗时，链表反之。两者有点能结合?树或许可以回答这个问题。 术语及性质 节点的深度、树的深度与高度 ​ 树中的元素也称作节点（Node），每个节点的深度都是一个非负整数；深度为0 的节点有且仅有一个，称作树根（Root）；对于深度为k (k≥1)的每个节点u，都有且仅有一个深度为k-1 的节点v 与之对应，称作u 的父亲（Parent）或父节点。定义四.2 若节点v 是节点u 的父亲，则u 称作v 的孩子（Child），并在二者之间建立一条树边（Edge）。同一节点的孩子互称“兄弟”（Sibling）。树中所有节点的最大深度，称作树的深度或高度。树中节点的数目，总是等于边数加一。 度、内部节点与外部节点 ​ 任一节点的孩子数目，称作它的“度”（Degree）。至少拥有一个孩子的节点称作“内部节点”（Internal node）；没有任何孩子的节点则称作 “外部节点”（External node）或“叶子”（Leaf）。 路径 ​ 由树中k+1 节点通过树边首尾衔接而构成的序列{ (v0, v1), (v1, v2), …, (vk-1, vk) | k ≥ 0}，称作树中长度为k 的一条路径（Path）。由单个节点、零条边构成的路径也是合法的，其长度为0。树中任何两个节点之间都存在唯一的一条路径。若v 是u 的父亲，则depth(v) + 1 = depth(u)。从树根通往任一节点的路径长度，恰好等于该节点的深度。 祖先、后代、子树和节点的高度 每个节点都是自己的“祖先”（Ancestor），也是自己的“后代”（Descendent）； 若v 是u 的父节点的祖先，则v 也是u 的祖先； 若u 的父节点是v 的后代，则u 也是v 的后代。 除节点本身以外的祖先（后代），称作真祖先（后代）。任一节点v 的深度，等于其真祖先的数目。任一节点v 的祖先，在每一深度上最多只有一个。树T 中每一节点v 的所有后代也构成一棵树，称作T 的“以v 为根的子树（Subtree）”若子树v 的深度（高度）为h，则称v 的高度为h，记作height(v) = h。对于叶子节点u 的任何祖先v，必有depth(v) + height(v) ≥ depth(u)。 共同祖先及最低共同祖先 在树T 中，若节点u 和v 都是节点a 的后代，则称节点a 为节点u 和v 的共同祖先（Commonancestor）。每一对节点至少存在一个共同祖先。在一对节点u 和v 的所有共同祖先中，深度最大者称为它们的最低共同祖先（Lowerestcommon ancestor），记作lca(u, v)。每一对节点的最低共同祖先必存在且唯一。 有序树、m 叉树 在树T 中，若在每个节点的所有孩子之间都可以定义某一线性次序，则称T 为一棵“有序树（Ordered tree）”每个内部节点均为m 度的有序树，称作m 叉树。 二叉树 每个节点均不超过2 度的有序树，称作二叉树（Binary tree）。不含1 度节点的二叉树，称作真二叉树（Proper binary tree），否则称作非真二叉树 （Improper binary tree）。在二叉树中，深度为k 的节点不超过2k 个。高度为h 的二叉树最多包含2h+1-1 个节点。由n 个节点构成的二叉树，高度至少为⎣log2n⎦。在二叉树中，叶子总是比2 度节点多一个。 满二叉树与完全二叉树 若二叉树T 中所有叶子的深度完全相同，则称之为满二叉树（Full binary tree）高度为h 的二叉树是满的，当且仅当它拥有2h 匹叶子、2h+1-1 个节点。若在一棵满二叉树中，从最右侧起将相邻的若干匹叶子节点摘除掉，则得到的二叉树称作完全二叉树（Complete binary tree）。由n 个节点构成的完全二叉树，高度h = ⎣log2n⎦。在由固定数目的节点所组成的所有二叉树中，完全二叉树的高度最低。 树抽象数据类型及其实现 二、常用算法 排序 1、冒泡排序 2、选择排序 3、插入排序 4、希尔排序 5、归并排序 6、快速排序 然后基准两边分别快速排序 7、堆排序 8、计数排序 9、桶排序 10、基数排序 查找 1. 顺序查找 2. 二分查找 3. 插值查找 4. 斐波那契查找 5. 树表查找 6. 分块查找 7. 哈希查找 三、算法题 2.18题目：序号-题目 思路1： 123思路1优点：缺点： 代码1： 1代码1 思路2： 123思路2优点：缺点： 代码2： 1代码2 参考文献：数据结构预算法(Java描述)邓俊辉","link":"/2021/02/19/Draft/2021/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"快查","text":"Linux,Shell,软件等常用命令快捷键 CMD netstat -aon|findstr &quot;59207&quot;查找对应端口pid tasklist|findstr &quot;1396&quot;查看对应pid程序 taskkill /t /f /pid &quot;8888&quot;关闭对应端口 mstsc 启动远程桌面 gpedit.msc策略组 HEXO Hexo c 清理 Hexo g编译 Hexo s运行 Hexo d部署 hexo new draft（scaffolds中模板名字）“标题”新建草稿 在source/_drafts目录 hexo new “标题”新建文档 hexo publish “标题”草稿移动到source/_post目录 IDEA ctrl +R 替换 LINUX yum install net-tools 安装网络工具 linux可直接复制给别人，复制VMware工作目录然后直接打开 su 回车输入密码转换为超级管理员 ifconfig查询网络相关 clear清空显示 ifconfig eth0 192.16.。。。设置IP地址 命令多数为临时生效，写入配置文件为永久生效 ls [-选项][参数]：ls -la /etc 目录处理命令（list） ls -a/l/lh/ld/i 隐藏文件/文件详细信息/大小单位显示/查看目录信息/查看文件id d l 文件开头 文件、目录、软连接 权限 mkdir【make directories】 创建目录 -p递归创建 创建没有此目录下的目录，可同时创建多个mkdir /tmp/a/b /tmp/a/c cd 【change directory】切换目录 cd ..返回上一级目录 pwd【print working directory】 cd ./.. 当前目录/上级目录 remdir【remove empty dirctories】 删除空目录 cp【copy】复制 源文件 目录 -r复制目录 -p复制并保留文件属性（比如创建时间） 复制并改名 mv【move】 剪切 rm【remove】删除文件，目录 -r删除目录 -f强制删除 -rf直接删除 ctrl+c终止操作 touch 创建文件 可创建多个，创建空格文件名使用双引号但是不建议 cat 浏览文件内容 -n显示行号 tac 倒置浏览文件内容 more 分页显示长文件 空格翻页，回车换行，q退出， less 显示文件内容，可向上翻页pageup，可搜索：/关键词 n显示下一个搜索结果 head 只看文件前几行 -n 7 文件 显示前7行，默认前十行 tail 同上 -f动态显示变化 ctrl+c退出 ln【link】 -s创建软连接 不写-s创建硬链接【软连接相当于快捷方式rwxrwxrwx，权限跟源文件权限无关，硬链接相当于拷贝cp -p并且同步更新，硬链接通过i节点区分，不能跨分区（相当于不能c盘复制到d盘），不能针对目录使用】 yum -y install git sudo -s1获得管理员权限 命令：sudo -s回车 输入密码 编辑保存文件----------------------------------- 第一步：cd到该文件的目录下 第二步：vi 要编辑的文件名，进入普通模式，（可以查看文件内容） sudo gedit /etc/apt/sources.list 可视化编辑 第三步：输入 i 进入编辑模式，开始编辑文本 第四步：编辑之后，按ESC退出到普通模式。 第五步：在普通模式下，输入 : 进入命令模式 第六步：在命令模式下输入wq, 即可保存并退出 【#】代表 root权限 【$】代表普通用户 reboot重启 BUG————————————————————————————– centos7 cannot find a valid baseurl for repo············· https://blog.csdn.net/jiankunking/article/details/82770502 zlib.h: No such file or directory························ yum install zlib-devel CentOS Name or service not known·································· vi /etc/sysconfig/network-scripts/ifcfg-ens33命令来编辑配置文件 Job for network.service failed because the control process exited with error code········································································ 关闭 NetworkManger 服务就好了， service NetworkManager stop 禁止开机启动 chkconfig NetworkManager off su: Authentication failure····················································· sudo passwd root 网络————————————————————————————— 1systemctl restart network //重启网卡 ====ifup eth0（网卡名称） ip addr查询网络信息 postgresql——————————————————————————- sudo -u postgres psql 进入psql交互环境 alter user postgres with password'密码'; 修改postgres用户的密码 \\q 退出数据库 shp导入到postgresql——————————————————————— shp2pgsql -s 4544 -c -W &quot;UTF-8&quot; ADDRESS.shp public.rrrrr| psql -h 192.168.22.128 -d postgres -U postgres -W 转换格式——————————————————————— ogr2ogr -f &quot;GeoJSON&quot; ./natural.json PG:&quot;host=localhost dbname=postgres user=postgres password=724111&quot; -sql &quot;select * from natural&quot; 切片—————————————————————————————— tippecanoe -z 14 -Z 5 -ps -Bg -o buildings.mbtiles buildings.json tippecanoe -e lakepbf -pC -Z1 -z17 -f natural.json NPM npm install ---install dependencies npm run dev---serve with hot reload at localhost:8080 npm run build---build for production with minification npm run build --report----build for production and view the bundle analyzer report npm run unit---run unit tests npm run e2e---run e2e tests npm test----run all tests REDIDS ./redis-server redis.windows.conf 启动服务 VSCODE ctrl+~ ：打开终端 F1 或 Ctrl+Shift+P（俗称万能键） ：打开命令面板。在打开的输入框内，可以输入任何命令 代码格式化: Shift+Alt+F VUE 脚手架 npm config set registry https://registry.npm.taobao.org vue init webpack projectName cd projectName npm install npm run dev npm i element-ui -S npm install axios","link":"/2021/02/25/Draft/2021/%E5%BF%AB%E6%9F%A5/"},{"title":"魑魅先生 | 每日英语","text":"图解日常英语单词 通俗易懂的英语语法 本土语言记录 口语练习记录","link":"/2021/02/25/Draft/2021/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"},{"title":"魑魅先生 | 每日面题","text":"面试题不但是门槛，也是检测。 Java刷题 主要分类： JVM，网络，Java基础，算法数据结构，数据库高级知识，框架原理，设计模式，分布式 Java基础 查看JAVA基础项目并补充，包含java基础， JVM 网络 算法数据结构 数据库高级知识 框架原理 设计模式 分布式","link":"/2021/03/01/Draft/2021/%E6%AF%8F%E6%97%A5%E9%9D%A2%E9%A2%98/"},{"title":"GIS","text":"MAPBOX流程 准备：熟悉linux 安装、网络、文件等基本操作，JS、HTML等熟悉，Mapbox熟悉，SQL熟悉，，， Ubuntu环境准备===》其他格式数据===》shp数据===》Windows导入postgresql数据库===》通过ogr2ogr转换为geojson===》通过tippecanoe切片（参数自控）》~~数据打包（传输更快）~~windows共享文件夹=》准备mapbox2000 js css文件====》mapbox前端代码导入数据并显示====》准备图标数据===》filter分类图标显示=====》分层数据显示====》细节优化（颜色，光，字体大小，图片大小）》加入点击显示位置》其他点击功能====》wfts底图切换==》控件加载===》wfs，wms数据加载（不同数据源）==》其他模型加入 详细步骤 环境准备 Ubuntu虚拟机： 网络环境，数据共享，Postgresql，Tippecanoe，PROJ.4、GEOS和GDAL（ogr2ogr），gcc、g++、make windows： Postgresql,VMware,Ubuntu镜像（官方指定），Navicat（方便查看数据和建立空间数据库），VSCode 详细步骤： 安装Postgresql数据库，环境配置，导入shp Windows安装Postgresql 下载 环境变量添加 设置外网访问（pg_hba.conf） 1234567891011# TYPE DATABASE USER ADDRESS METHOD# IPv4 local connections:host all all 127.0.0.1/32 md5host all all 0.0.0.0/0 md5# IPv6 local connections:host all all ::1/128 md5# Allow replication connections from localhost, by a user with the# replication privilege.#host replication postgres 127.0.0.1/32 md5#host replication postgres ::1/128 md5 建立空间数据库,目标数据库执行以下语句 1234create extension postgis;create extension postgis_topology;create extension fuzzystrmatch;create extension postgis_tiger_geocoder; 在SHP文件夹新建txt文件，粘贴以下代码，导入数据到数据库，相关参数如下，改成bat后缀，双击运行后输入密码，显示类似 insert 1成功 123shp2pgsql -s 4544 -c -W “GBK” DJQ5120812018.shp public.DJQ5120812018 | psql -d shp2pgsqldemo -U postgres -W示例 ：shp2pgsql -s 4544 -c -W &quot;UTF-8&quot; ADDRESS.shp public.rrrrr| psql -h 192.168.22.128 -d postgres -U postgres -W 编码格式 SHP数据 public下的rrrrr表 导入数据库地址 数据库名 用户名 也可分为两个步骤，先转换为sql语句，再导入,步骤同上 12shp2pgsql -s 4544 -c -W “GBK” DJQ5120812018.shp&gt;DJQ5120812018.sqlpsql -d shp2pgsqldemo -U postgres -f DJQ5120812018.sql -W 可能出现的问题 解决办法 乱码 更改编码 导入中断，数据库无数据 数据过大 参数 含义 -s 空间参考标识符（SRID） -d 重新建立表，并插入数据 -a 在同一个表中增加数据 -c 建立新表，并插入数据(缺省) -p 只创建表 -g 指定要创建的表的空间字段名称(在追加数据时有用) -D 使用dump方式，比缺省生成sql的速度快 -G 使用类型geography -k 保持标识符（列名，模式，属性）大小写。 -i 将所有整型都转为标准的32-bit整数 -I 在几何列上建立GIST索引 -S 生成简单几何，而非MULTI几何 -t 指定几何的维度 -w 指定输出格式为WKT -W 输入的dbf文件编码方式 -N 指定几何为空时的操作 -n 只导入dbf文件 -T 指定表的表空间 -X 指定索引的表空间 -? 帮助 通过ogr2ogr转换为geojson 12ogr2ogr -f &quot;GeoJSON&quot; ./asstln.json PG:&quot;host=localhost dbname=postgres user=postgres password=111111&quot; -sql &quot;select * from asstln&quot; 目标文件名 导出数据库连接信息 导出表名 通过tippecanoe切片（参数自控） 单数据源 12tippecanoe -e tracenln -pC -Z0 -z20 -f tracenln.json 目标文件夹 切片等级空值 源文件名 单层多数据源合并 123#where确定级别ogr2ogr -f &quot;GeoJSON&quot; ./veg_py.json PG:&quot;host=126.10.9.16 dbname=postgres user=postgres password=724111&quot; -sql &quot;select * from veg_py fscale=10&quot; tippecanoe -e tracenln -pC -Z0 -z20 -f tracenln1.json tracenln2.json tracenln3.json 参数查看 数据打包 复制到编程端（传输更快） windows文件共享文件夹，或Tomcat，或在线服务器以便数据调用，注意解决触跨域资源访问 准备mapbox2000 js css文件 windows 安装 git Node.JS 安装说明 Yarn安装、配置、镜像源修改 12npm install --global yarnyarn --version Node.js安装本地插件构建工具node-gyp GitHub Mapbox源码地址：https://github.com/mapbox/mapbox-gl-js 2000坐标源码， 项目编译 yarn install 安装headless-gl，并将node_modules/headless-gl/deps/windows/dll/x64/*.dll 复制到c:\\windows\\system32 npm install gl yarn run start-debug yarn run build-dev 准备好js和css文件 mapbox 前端代码导入地图数据并显示 3D模型 针对对应的建筑数据，进行建筑物3D显示 123456789101112131415161718paint: { // 'fill-color': 'red', // 'fill-opacity': 1, 'fill-extrusion-color': '#f5f4ee', // use an 'interpolate' expression to add a smooth transition effect to the // buildings as the user zooms in 'fill-extrusion-height': [ &quot;interpolate&quot;, [&quot;linear&quot;], [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;height&quot;] ], 'fill-extrusion-base': [ &quot;interpolate&quot;, [&quot;linear&quot;], [&quot;zoom&quot;], 15, 0, 15.05, [&quot;get&quot;, &quot;min_height&quot;] ], 'fill-extrusion-opacity': 0.85 }, vscode 插件服务器 插件安装 Live Server 准备图标数据，PBF字体数据 https://github.com/mapbox/spritezero 从零生成图标资源工具，可网上下载 生成如图形式文件， filter 分类图标显示 123456789101112131415'filter': [ 'any', [ '==', 'fcode', '4206002500'//2 ] ,[ '==', 'fcode', '4305010500'//2 ] ], 分层数据显示 1&quot;layers&quot;: []//中越靠前的在底层 细节优化（颜色，光，字体大小，图片大小） 控件加载 Supermap查看 加入点击显示相关信息 123456789101112131415//弹出框​ map.on('click', function (e) {​ var features = map.queryRenderedFeatures(e.point, {​ layers: ['13'] // replace this with the id of the layer​ });​ if (!features.length) {​ return;​ }​ var feature = features[0];​ var popup = new mapboxgl.Popup({ offset: [0, -15] })​ .setLngLat(feature.geometry.coordinates)​ .setHTML('&lt;h3&gt;' + feature.properties.shortname + '&lt;/h3&gt;&lt;p&gt;' + feature.properties.name + '&lt;/p&gt;')​ .addTo(map);​ }); wfts 底图切换 wfs，wms 数据加载（不同数据源） 定位 数据查询 数据可视化 Supermap查看 优化 窗口样式优化，弹出框样式优化，字体等调节 一些小技巧 待更新 Mapbox源码编译 环境准备 GIT环境搭建： 详细点击：（一）windows 安装 git Node.JS环境搭建： 详细点击：（一）Node.JS 安装说明 Yarn环境搭建： 详细点击：（一）Yarn安装、配置、镜像源修改 12npm install --global yarnyarn --version Npm and node-gyp依赖安装 详细点击：（二）Node.js安装本地插件构建工具node-gyp 其他地址： GitHub Mapbox源码地址：https://github.com/mapbox/mapbox-gl-js 项目编译 yarn install 安装headless-gl，并将node_modules/headless-gl/deps/windows/dll/x64/*.dll 复制到c:\\windows\\system32 npm install gl yarn run start-debug yarn run build-dev debug/index.html中代码最上方增加token mapboxgl.accessToken='pk.eyJ1IjoibGltbiIsImEiOiJja2t1bG1na2IxZGU0MnZvNmlzY3FhZXM4In0.oQx4VguycOR4TK80Pyusmw'; var map = window.map = new mapboxgl.Map({ MAPBOX专业术语 矢量瓦片： 栅格瓦片： MAPBOX学习 中文文档：http://www.mapbox.cn/mapbox-gl-js/api/ Styles (8) 为地图添加生成的图标 为地图添加动画图标 为地图生成及添加缺失的图标 为地图添加图标 使用自定义样式展示地图 显示卫星地图 改变一个地图的样式 显示一个地图 Layers (30) 用3D形式呈现建筑物 拉伸多边形以绘制3D室内地图 添加3D模型 调整图层不透明度 为线添加动画效果 为一系列图像添加动画效果 为点添加动画效果 按照缩放级别改变建筑颜色 更改标注的大小写 显示具有自定义属性的HTML聚类 创建样式聚类 使用按钮更改图层颜色 添加自定义样式图层 给线添加数据驱动属性的样式。 给圆添加数据驱动属性的样式 显示多种文本格式并设置其样式 为多边形添加图案 在标签下添加新图层 添加 GeoJSON 线 绘制 GeoJSON 点 添加 GeoJSON 多边形 创建热力图图层 添加晕暄 使用表达式创建渐变色线条 设置海洋深度数据样式 显示和隐藏图层 改变行政边界世界观 根据缩放级别更新等值线图层 变量标签位置 可视化人口密度 Sources (9) 将本地JSON数据与矢量切片图形连接 添加影像 添加实时数据 更新实时要素 添加栅格切片数据源 添加一个第三方矢量切片来源 添加一个矢量图片数据源 添加一个视频 添加一个 WMS 源 User interaction (17) 基于周边声音给3D建筑添加动画效果 禁用地图旋转 创建可拖动的点 创建可拖动的标记（Marker） 通过文本输入筛选符号 在 map view 中筛选要素 通过切换列表筛选符号 创建悬停效果 显示非交互式地图 更改地图的语言 高亮包含相似数据的部分 从点击点周围选择特征 限制地图平移在某一区域 获取鼠标下点的特征 切换交互 创建时间滑动条 高亮一个选择框范围内的特征 Camera (11) 使地图相机环绕一点运动 为路线中的点添加动画效果 将地图居中于被单击的符号上 缓慢飞至某个位置 将地图缩放至边界框内 飞至某一位置 使用游戏式控件浏览地图 跳至一系列地点 以幻灯片形式播放地图位置。 根据滚动位置飞到某处 设置 pitch 和 bearing Controls and overlays (16) 为标记(marker)添加动画效果 改变注释的默认位置 使用 Markers 添加自定义图标 禁用滚轮缩放 全屏查看地图 定位用户 在不同地图之间滑动 显示驾驶方向 显示已绘制的多边形区域 添加地理编码器 利用地点名称添加标记 点击时显示多边形信息 悬浮时显示弹出窗 点击时显示一个弹出窗 显示一个弹出窗 将弹出窗口附加到 marker 实例 Geocoder (8) 从其他数据源中补充进一步的地理编码查询结果 接收输入坐标至地理编码器 使用地理编码器时采用自定义渲染功能 将地理编码的结果限制在指定地区范围内 在使用地理编码器的过程中结合使用自定义相机动画 在地图上添加位置搜索框 将地理编码器进行指定语言的本地化 在Geocoder产生结果后设置一个点 Browser support (1) 检查浏览器支持 Internationalization support (2) 使用本地生成的表意文字 为从右至左书写的脚本提供支持 SUPERMAP 一个mapbox华丽外衣与装备 Leaflet an open-source JavaScript library for mobile-friendly interactive maps Cygwin windows使用linux环境（部分机型失败） Tippecanoe Tippecanoe是Mapbox的一个开源切片工具，项目地址：https://github.com/mapbox/tippecanoe，Mapbox常规的切片方法tilelive-copy参见另一篇博客。Tippecanoe主要在处理大数据量时有很大的优势，具有很高的效率，并且有很多参数可以控制。Tippecanoe只能处理GeoJSON，因此在切片前需要将矢量数据转换为GeoJSON，推荐使用ogr2ogr工具转换。切片以后的格式为mbtiles，可自行导入mongodb等数据库。 目的：根据你的数据创造一个可自由缩放的视图 引用地址：https://my.oschina.net/u/1464512/blog/1631972 常用tippecanoe参数设置 GEOJSON GeoSever GeoServer是OGC Web服务器规范的J2EE实现，利用GeoServer可以方便地发布地图数据，允许用户对特征数据进行更新、删除、插入操作，通过GeoServer可以比较容易地在用户之间迅速共享空间地理信息。GeoServer是开源软件。 GeoServer主要包含如下一些特点： 兼容WMS和WFS特性 支持PostGIS、Shapefile、ArcSDE、Oracle、VPF、MySQL、MapInfo 支持上百种投影 能够将网络地图输出为JPEG、GIF、PNG、SVG、KML等格式 能够运行在任何基于J2EE/Servlet容器之上 嵌入MapBuilder支持AJAX的地图客户端OpenLayers 引用地址 WMS &amp;&amp; WFS WMS是由服务器将一地图图像发送给客户端，而WFS是服务器将矢量数据发送给客户端，也就是在使用WMS时地图由服务器绘制，在使用WFS时地图由客户端绘制。 WFTS","link":"/2021/02/22/Draft/2021/GIS/"},{"title":"魑魅先生 | 资源篇","text":"JVM 与上层技术 魑魅先生 | 资源篇 魑魅先生 | 资源篇 一.程序员书屋（编程相关，Kindle 相关 一共112个 G 资源） Java资源101个 G 囊括大部分 Java 开发小白到全栈大神所需阅读全部书籍，设计模式、网络、算法、框架、职场经验 ​ 关注公众号发送 小书屋 获取下载链接 不仅如此，还有 Kindle 各类电子书籍11个G 索引在此点击 搜索之后有需要的 关注公众号发送 Kindle获取下载链接！ 二.学习网站（持续更新中） 1.编程网站： Refactoring.Guru ​ 设计模式在线学习，程序员之间的沟通语言，学习必不可少的知识，有各种代码示范，UML图，动漫演示。 Visualgo ​ 算法在线可视化过程，理解更加容易，过程速度可调，步骤可控，代码可观。 Github ​ 将自己的学习代码进行版本化管理，将学习资源整理归纳，学习别人的优秀项目，获取全球最新资源，好处就不一一列举了，每个程序员都了解。 CSDN ​ 一个人的成就往往不在于得到多少，而在于输出多少，一个有贡献的程序员往往是会分享的。这个博客网站汇聚很多大牛，也有很多 demo，让你可以不重复造轮子。 2.设计网站： doyoudo ​ 学习 Ae、Ps、Pr、C4D、乐理等等。印象中小白老师的生动课堂是让我对设计感兴趣第一原因，也是第一个让我有想上付费课冲动的学习网站。 Colordrop ​ 配色网站，直观且复制方便，妈妈再也不用担心我的配色了。 创客贴 ​ 不会 PS 没关系，创客贴直接拉动修改元素，一切都直接设计好了，小白式拖动便可快速完成设计更改，还可以直接修改 GIF 动图！ 3.通用网站： Bilibili 不仅仅有鬼畜，你想有的教程都有，摄影、设计、编程、绘画等，是现代学习者不可缺少聚集地。 Coursera 国外学习网站，免费资源很多，可以接触更加及时的知识。 三.软件推荐（持续更新中） 电脑篇 英语语法书写纠正，毕竟语法纠正除了老师就只有他了。 自媒体必备，Markdown最佳利器。 字体中央管理，免费商用就够你用一辈子了，版权问题不用考虑了 Markdown图床管理优秀软件之一 有他还要啥百度云，配合chrome使用更香 你有个ipad放那盖泡面不如拿来用作你的第二屏幕 艾宾浩斯遗忘曲线最佳实践，记忆任何知识，自主卡片形式 目前使用过的最佳思维导图软件 三端互传文件，无缝同步，在鸿蒙系统出来之前它可能一直是我的主力 安卓可用，电脑操控手机，可无线控制，上班划水利器，免费开源 抓包，测试，网络模拟，新世界，一不小心从抓包到入狱 浏览器插件 ​ chrome有了它，啥会员都不用开。 ​ 有了它，任何复杂页面都可以变得小清新。 ipad篇 （待更新[如何抓包获取各种围哎皮，如何高效率利用学习软件]） 手机篇 （待更新[各种黑科技小工具]） ​ 魑魅先生，一只拼搏成为魑魅大能的小鬼(●—●) 四.设计资源（持续更新中） ​ 包括各大海报，字体，笔刷，素材，LOGO，全家桶等等，公众号回复设计资源获取下载链接 ​ ! 五.视频资源（持续更新中） Java，Python相关基础到架构课程，项目实战 ​ ​ 音乐相关 ​ 吉他，尤克里里，乐理，编曲，作词，相关软件，声源 ​ ​ 绘画 语言 摄影 ​ 包含美国摄影学院摄影教材，学习摄影不可缺少的书籍 最后想说，资源虽多，但如果只当一个收藏党那永远不会是你的。只有在这飞速发展的时代，卸去浮躁，一点点消化，才会让成为你茁壮成长的养分。 ​ 资源分享，部分资源请勿作商业用途，如有侵权，联系删除。如果有能力，请支持正版！","link":"/2021/01/28/Draft/2021/%E8%B5%84%E6%BA%90%E7%AF%87/"},{"title":"魑魅先生 | Redis","text":"Redis Nosql由来 单机mysql mysql+缓存+垂直拆分 主从读写分离 分表分库+水平拆分+mysql集群 现在用户社交网络数据成倍增长，sql难以支撑 简介 开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 redis的应用场景有哪些 1、会话缓存（最常用） 2、消息队列，比如支付 3、活动排行榜或计数 4、发布、订阅消息（消息通知） 5、商品列表、评论列表等 REmote DIctionary Server（远程字典服务器），开源，C语言编写 NoSQL（Not Only SQL）非关系型数据库 不需要固定模式，无需多于操作就可以横向操作 3V+3高 大数据时代3V 海量Volume 多样Variety 实时Velocity 互联网需求3高 高并发 高可扩 高性能 经典应用 阿里巴巴 四大分类 KV键值对 文档型数据库 列存储数据库 图关系数据库 CAP C：Consistency（强一致性） A:Availability（可用性） P：Partition tolerance（分区容错性） 三进二（C必实现） CA 单点集群，满足一致性 CP AP BASE 基本可用（Basically Available） 软状态（Soft state） 最终一致性（Eventually consistent） 分布式与集群 子主题 1 ACID关系型数据库 企业里面几乎不用windows开发Redis Redis 安装 https://github.com/tporadowski/redis/releases redis-server.exe redis.windows.conf 另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了 redis-cli.exe -h 127.0.0.1 -p 6379 set myKey abc get myKey Redis 配置 Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。 你可以通过 CONFIG 命令查看或设置配置项。 CONFIG GET CONFIG_SETTING_NAME CONFIG GET loglevel CONFIG GET * 编辑配置 可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。 CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE CONFIG SET loglevel &quot;notice&quot; 参数说明 redis.conf 配置项说明如下： https://www.runoob.com/redis/redis-conf.html Redis 数据类型 String（字符串） string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 SET runoob &quot;菜鸟教程&quot; GET runoob Hash（哈希） Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 - DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value - HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。 每个 hash 可以存储 232 -1 键值对（40多亿）。 HMSET runoob field1 &quot;Hello&quot; field2 &quot;World&quot; HGET runoob field1 List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 lpush runoob redis lpush runoob mongodb lrange runoob 0 10 Set（集合） Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 sadd 命令 添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 sadd key member 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 sadd runoob redis smembers runoob zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 zadd 命令 添加元素到集合，元素在集合中存在则更新对应score zadd key score member zadd runoob 0 redis ZRANGEBYSCORE runoob 0 1000 Redis 命令 Redis 命令 语法 Redis 客户端的基本语法为： $ redis-cli - 以下实例讲解了如何启动 redis 客户端： 启动 redis 服务器，打开终端并输入命令 redis-cli，该命令会连接本地的 redis 服务。 $ redis-cli redis 127.0.0.1:6379&gt; redis 127.0.0.1:6379&gt; PING PONG 在以上实例中我们连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。 在远程服务上执行命令 $ redis-cli -h host -p port -a password Redis keys 命令大全 https://redis.io/commands Redis HyperLogLog Redis 在 2.8.9 版本添加了 HyperLogLog 结构。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 什么是基数? 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 PFADD runoobkey &quot;redis&quot; PFCOUNT runoobkey Redis 发布订阅 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 SUBSCRIBE runoobChat PUBLISH runoobChat &quot;Redis PUBLISH test&quot; 重新开启个 redis 客户端在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。 - Redis 事务(不回滚，批量执行作用) Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 MULTI 开始一个事务 将多个命令入队到事务中 SET book-name &quot;Mastering C++ in 21 days&quot; GET book-name SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot; SMEMBERS tag EXEC 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 Redis 脚本 Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。 EVAL script numkeys key [key ...] arg [arg ...] EVAL &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second Redis 连接 Redis 连接命令主要是用于连接 redis 服务。 客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行： AUTH &quot;password&quot; PING 1 AUTH password 验证密码是否正确 2 ECHO message 打印字符串 3 PING 查看服务是否运行 4 QUIT 关闭当前连接 5 SELECT index 切换到指定的数据库 Redis服务器 Redis服务器命令主要是用于管理redis服务 Redis GEO Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。 Redis GEO 操作方法有： geoadd：添加地理位置的坐标。 geopos：获取地理位置的坐标。 geodist：计算两个位置之间的距离。 georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。 georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。 geohash：返回一个或多个位置对象的 geohash 值。 geoadd geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。 geoadd 语法格式如下： GEOADD key longitude latitude member [longitude latitude member ...] - GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; - GEODIST Sicily Palermo Catania - geodist 用于返回两个给定位置之间的距离。 geodist 语法格式如下： GEODIST key member1 member2 [m|km|ft|mi] member1 member2 为两个地理位置。 最后一个距离单位参数说明： m ：米，默认单位。 km ：千米。 mi ：英里。 ft ：英尺。 - GEORADIUS Sicily 15 37 100 km - georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。 georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。 georadius 与 georadiusbymember 语法格式如下： GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] 参数说明： m ：米，默认单位。 km ：千米。 mi ：英里。 ft ：英尺。 WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 WITHCOORD: 将位置元素的经度和维度也一并返回。 WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。 COUNT 限定返回的记录数。 ASC: 查找结果根据距离从近到远排序。 DESC: 查找结果根据从远到近排序。 - GEOPOS Sicily Palermo Catania NonExisting - geopos 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。 geopos 语法格式如下： GEOPOS key member [member ...] - GEOHASH Sicily Palermo Catania - geohash Redis GEO 使用 geohash 来保存地理位置的坐标。 geohash 用于获取一个或多个位置元素的 geohash 值。 geohash 语法格式如下： GEOHASH key member [member ...] Redis Stream Redis Stream 是 Redis 5.0 版本新增加的数据结构。 Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。 简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。 而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。 Redis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容： - 子主题 1 - 每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。 上图解析： Consumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。 last_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。 pending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。 - 消息队列相关命令： XADD - 添加消息到末尾 XTRIM - 对流进行修剪，限制长度 XDEL - 删除消息 XLEN - 获取流包含的元素数量，即消息长度 XRANGE - 获取消息列表，会自动过滤已经删除的消息 XREVRANGE - 反向获取消息列表，ID 从大到小 XREAD - 以阻塞或非阻塞方式获取消息列表 消费者组相关命令： XGROUP CREATE - 创建消费者组 XREADGROUP GROUP - 读取消费者组中的消息 XACK - 将消息标记为&quot;已处理&quot; XGROUP SETID - 为消费者组设置新的最后递送消息ID XGROUP DELCONSUMER - 删除消费者 XGROUP DESTROY - 删除消费者组 XPENDING - 显示待处理消息的相关信息 XCLAIM - 转移消息的归属权 XINFO - 查看流和消费者组的相关信息； XINFO GROUPS - 打印消费者组的信息； XINFO STREAM - 打印流信息 XADD 使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列，XADD 语法格式： XADD key ID field value [field value ...] key ：队列名称，如果不存在就创建 ID ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。 field value ： 记录。 - XADD mystream * name Sara surname OConnor - XADD mystream * field1 value1 field2 value2 field3 value3 - XLEN mystream - XRANGE mystream - + XTRIM 使用 XTRIM 对流进行修剪，限制长度， 语法格式： XTRIM key MAXLEN [~] count key ：队列名称 MAXLEN ：长度 count ：数量 - XADD mystream * field1 A field2 B field3 C field4 D - XTRIM mystream MAXLEN 2 - XRANGE mystream - + XDEL 使用 XDEL 删除消息，语法格式： XDEL key ID [ID ...] key：队列名称 ID ：消息 ID 使用 XDEL 删除消息，语法格式： XLEN 使用 XLEN 获取流包含的元素数量，即消息长度，语法格式： XLEN key key：队列名称 - XADD mystream * item 1 - XLEN mystream XRANGE 使用 XRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式： XRANGE key start end [COUNT count] key ：队列名 start ：开始值， - 表示最小值 end ：结束值， + 表示最大值 count ：数量 - XADD writers * name Ngozi surname Adichie - XLEN writers - XRANGE writers - + COUNT 2 XREVRANGE 使用 XREVRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式： XREVRANGE key end start [COUNT count] key ：队列名 end ：结束值， + 表示最大值 start ：开始值， - 表示最小值 count ：数量 - XADD writers * name Virginia surname Woolf - XLEN writers - XREVRANGE writers + - COUNT 1 XREAD 使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式： XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...] count ：数量 milliseconds ：可选，阻塞毫秒数，没有设置就是非阻塞模式 key ：队列名 id ：消息 ID - # 从 Stream 头部读取两条消息 XREAD COUNT 2 STREAMS mystream writers 0-0 0-0 XGROUP CREATE 使用 XGROUP CREATE 创建消费者组，语法格式： XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername] key ：队列名称，如果不存在就创建 groupname ：组名。 $ ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。 从头开始消费: XGROUP CREATE mystream consumer-group-name 0-0 从尾部开始消费: XGROUP CREATE mystream consumer-group-name $ XREADGROUP GROUP 使用 XREADGROUP GROUP 读取消费组中的消息，语法格式： XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] group ：消费组名 consumer ：消费者名。 count ： 读取数量。 milliseconds ： 阻塞毫秒数。 key ： 队列名。 ID ： 消息 ID。 XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt; Redis 高级教程 Redis 数据备份与恢复 SAVE 该命令将在 redis 安装目录中创建dump.rdb文件。 如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令 CONFIG GET dir 以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/bin。 Bgsave 创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。 实例 127.0.0.1:6379&gt; BGSAVE Background saving started Redis 安全 通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。 查看是否设置了密码验证： CONFIG get requirepass默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。 CONFIG set requirepass &quot;runoob&quot; AUTH &quot;runoob&quot; SET mykey &quot;Test value&quot; GET mykey Redis 性能测试 Redis 性能测试是通过同时执行多个命令实现的。 redis-benchmark [option] [option value] 注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令 以下实例同时执行 10000 个请求来检测性能： redis-benchmark -n 10000 -q - redis 性能测试工具可选参数如下所示： 序号 选项 描述 默认值 1 -h 指定服务器主机名 127.0.0.1 2 -p 指定服务器端口 6379 3 -s 指定服务器 socket 4 -c 指定并发连接数 50 5 -n 指定请求数 10000 6 -d 以字节的形式指定 SET/GET 值的数据大小 2 7 -k 1=keep alive 0=reconnect 1 8 -r SET/GET/INCR 使用随机 key, SADD 使用随机值 9 -P 通过管道传输 请求 1 10 -q 强制退出 redis。仅显示 query/sec 值 11 --csv 以 CSV 格式输出 12 -l 生成循环，永久执行测试 13 -t 仅运行以逗号分隔的测试命令列表。 14 -I Idle 模式。仅打开 N 个 idle 连接并等待。 - redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q Redis 客户端连接 Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作： 首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。 然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法 然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送 最大连接数 在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。 maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。 config get maxclients - redis-server --maxclients 100000 - S.N. 命令 描述 1 CLIENT LIST 返回连接到 redis 服务的客户端列表 2 CLIENT SETNAME 设置当前连接的名称 3 CLIENT GETNAME 获取通过 CLIENT SETNAME 命令设置的服务名称 4 CLIENT PAUSE 挂起客户端连接，指定挂起的时间以毫秒计 5 CLIENT KILL 关闭客户端连接 Redis管道技术 Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤： 客户端向服务端发送一个查询请求，并监听套接字返回，通常以一对模式，等待服务端响应。 服务端处理命令，可以结果返回给客户端。 Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。 查看redis管道，只需要启动redis实例并输入以下命令： $（echo -en“ PING \\ r \\ n SET runoobkey redis \\ r \\ nGET runoobkey \\ r \\ nINCR访问者\\ r \\ nINCR访问者\\ r \\ nINCR访问者\\ r \\ n”；睡眠10）| 数控本地主机6379（echo - zh - cn “ PING \\ r \\ n SET redoobkey redis \\ r \\ nGET runoobkey \\ r \\ nINCR访问者\\ r \\ nINCR访问者\\ r \\ nINCR访问者\\ r \\ n” ；睡眠10 ）| 数控本地主机6379 - 以上实例中我们通过使用PING命令查看redis服务是否可用，之后我们设置了runoobkey的变量redis，然后我们获取runoobkey的值并使其访客自增3次。 在返回的结果中我们可以看到这些命令一次性向redis服务提交，并最终一次性读取所有服务端的响应 管道技术的优势 管道技术最显着的优势是提高了redis服务的性能。 Redis 分区 分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。 分区的优势 通过利用多台计算机内存的和值，允许我们构造更大的数据库。 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。 分区的不足 redis的一些特性在分区方面表现的不是很好： 涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。 涉及多个key的redis事务不能使用。 当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。 增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。 分区类型 Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。 范围分区 最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。 比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。 这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。 哈希分区 另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单： 用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。 对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。 Java 使用 Redis 安装 开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。 Java的安装配置可以参考我们的 Java 开发环境配置 接下来让我们安装 Java redis 驱动： 首先你需要下载驱动包 下载 jedis.jar，确保下载最新驱动包。 在你的 classpath 中包含该驱动包。 连接到 redis 服务 import redis.clients.jedis.Jedis; public class RedisJava { public static void main(String[] args) { //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); // 如果 Redis 服务设置来密码，需要下面这行，没有就不需要 // jedis.auth(&quot;123456&quot;); System.out.println(&quot;连接成功&quot;); //查看服务是否运行 System.out.println(&quot;服务正在运行: &quot;+jedis.ping()); } } Redis Java String(字符串) 实例 import redis.clients.jedis.Jedis; public class RedisStringJava { public static void main(String[] args) { //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;连接成功&quot;); //设置 redis 字符串数据 jedis.set(&quot;runoobkey&quot;, &quot;www.runoob.com&quot;); // 获取存储的数据并输出 System.out.println(&quot;redis 存储的字符串为: &quot;+ jedis.get(&quot;runoobkey&quot;)); } } Redis Java List(列表) 实例 import java.util.List; import redis.clients.jedis.Jedis; public class RedisListJava { public static void main(String[] args) { //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;连接成功&quot;); //存储数据到列表中 jedis.lpush(&quot;site-list&quot;, &quot;Runoob&quot;); jedis.lpush(&quot;site-list&quot;, &quot;Google&quot;); jedis.lpush(&quot;site-list&quot;, &quot;Taobao&quot;); // 获取存储的数据并输出 List list = jedis.lrange(&quot;site-list&quot;, 0 ,2); for(int i=0; i&lt;list.size(); i++) { System.out.println(&quot;列表项为: &quot;+list.get(i)); } } } Redis Java Keys 实例 import java.util.Iterator; import java.util.Set; import redis.clients.jedis.Jedis; public class RedisKeyJava { public static void main(String[] args) { //连接本地的 Redis 服务 Jedis jedis = new Jedis(&quot;localhost&quot;); System.out.println(&quot;连接成功&quot;); // 获取数据并输出 Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); Iterator&lt;String&gt; it=keys.iterator() ; while(it.hasNext()){ String key = it.next(); System.out.println(key); } } } 自由主题","link":"/2021/03/01/Draft/2021/Redis/"},{"title":"SpringCloud","text":"Spring Cloud [Greenwich] 学习网址： https://www.springcloud.cc/spring-cloud-greenwich.html https://spring.io/projects/spring-cloud/ 学习资源： 黑马 #0. 学习目标 能够使用RestTemplate发送请求 能够说出SpringCloud的作用 能够搭建Eureka注册中心 能够使用Robbin负载均衡 能够使用Hystrix熔断器 1. 系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演 进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google 带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安逸得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习 现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1. 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 优点： 系统开发速度快 维护成本低 适用于并发要求较低的系统 缺点： 代码耦合度高，后期维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2. 垂直拆分 ​ 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆 分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3. 分布式服务 ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4. 面向服务架构（SOA） ​ SOA（Service Oriented Architecture）面向服务的架构：它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在与操作系统进程中。各个服务之间 通过网络调用。SOA结构图： ESB（企业服务总线），简单 来说 ESB 就是一根管道，用来连接各个服务节点。为了集 成不同系统，不同协议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通。 SOA缺点：每个供应商提供的ESB产品有偏差，自身实现较为复杂；应用服务粒度较大，ESB集成整合所有服务和协 议、数据转换使得运维、测试部署困难。所有服务都通过一个通路通信，直接降低了通信速度。 1.5. 微服务架构 ​ 微服务架构是使用一套小服务来开发单个应用的方式或途径，每个服务基于单一业务能力构建，运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，并能够通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。微服务结构图： API Gateway网关是一个服务器，是系统的唯一入口。为每个客户端提供一个定制的API。API网关核心是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。如它还可以具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。通常，网关提供RESTful/HTTP的方式访问服务。而服务端通过服务注册中心进行服务注册和管理。 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动端开 发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立：服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和 持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务架构与SOA都是对系统进行拆分；微服务架构基于SOA思想，可以把微服务当做去除了ESB的SOA。ESB是SOA架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。两者比较类似，但其实也有一些差别： #2. 服务调用方式 2.1. RPC和HTTP 无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下2种： RPC：Remote Produce Call远程过程调用，RPC基于Socket，工作在会话层。自定义数据格式，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表 Http：http其实是一种网络传输协议，基于TCP，工作在应用层，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。 现在热门的Rest风格，就可以通过http协议来实现。 区别：RPC的机制是根据语言的API（language API）来定义的，而不是根据基于网络的应用来定义的。 如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。 相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么Spring Cloud搭建微服务是不二之选。在我们的项目中，会选择Spring Cloud套件，因此会使用Http方式来实现服务间调用。 2.2. Http客户端工具 既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 不过这些不同的客户端，API各不相同。而Spring也有对http的客户端进行封装，提供了工具类叫RestTemplate。 2.3. Spring的RestTemplate Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和 反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） Spring Cloud [Finchley] ​ 一系列框架有序集合，封装后屏蔽了复杂的配置和实现原理。Spring Cloud为开发人员提供了工具，以快速构建分布式系统中的一些常见模式（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。分布式系统的协调导致样板式样，并且使用Spring Cloud开发人员可以快速站起来实现这些样板的服务和应用程序。它们将在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心以及诸如Cloud Foundry之类的托管平台。 1.系统架构演变 graph LR; 1[集中式架构] --> 2[垂直拆分] 2 --> 3[分布式服务] 3 --> 4[SOA面向服务架构] 4 --> 5[微服务架构] 微服务架构 一套使用小服务或者单一业务来开发单个应用的方式或途径。 微服务架构特点： 单一职责 服务粒度小 面向服务（对外暴露REST api） 服务之间相互独立 与使用ESB的SOA架构的区别： 微服务架构没有使用ESB，有服务治理注册中心；业务粒度小。 2.服务调用方式 RPC：基于socket，速度快，效率高；webservice、dubbo HTTP：基于TCP，封装比较臃肿；对服务和调用方没有任何技术、语言的限定，自由灵活；RESTful，Spring Cloud 一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用： httpClient okHttp JDK原生URLConnection spring 提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装，可在spring项目中使用RestTemplate进行服务调用。 小结： 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class RestTemplateTest { @Autowired private RestTemplate restTemplate; @Test public void test(){ String url = &quot;http://localhost/user/8&quot;; //restTemplate可以对json格式字符串进行反序列化 User user = restTemplate.getForObject(url, User.class); System.out.println(user); }} 3.SpringCloud概述 整合的组件可以有很多组件；常见的组件有：eureka注册中心，Gateway网关，Ribbon负载均衡，Feign服务调用，Hystrix熔断器。在有需要的时候项目添加对于的启动器依赖即可。 版本特征：以英文单词命名（伦敦地铁站名） 4.创建微服务工程 父工程springcloud：添加spring boot父坐标和管理其它组件的依赖 用户服务工程user-service：整合mybatis查询数据库中用户数据；提供查询用户服务 服务消费工程consumer-demo：利用查询用户服务获取用户数据并输出到浏览器 5.搭建配置Service工程 添加启动器依赖（web、通用Mapper）； 创建启动引导类和配置文件； 修改配置文件中的参数； 编写测试代码（UserMapper，UserService，UserController）； 测试 6.搭建配置Client工程 添加启动器依赖； 创建启动引导类（注册RestTemplate）和配置文件； 编写测试代码（ConsumerController中使用restTemplate访问服务获取数据） 测试 7.问题 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 上述问题通过springcloud各种组件解决 8.Eureka Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。 8.1Eureka-server Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。可以搭建web工程使用Eureka，可以使用Spring Boot方式搭建。 搭建步骤： 创建工程； 添加启动器依赖； 编写启动引导类（添加Eureka的服务注解）和配置文件； 修改配置文件（端口，应用名称...）； 启动测试 8.2服务注册与发现 服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址 服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址； 改造处理器类Controller，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。 8.3高可用配置 ​ 将Eureka Server作为一个服务注册到其它Eureka Server，这样多个Eureka Server之间就能够互相发现对方，同步服务，实现Eureka Server集群。 9.负载均衡Ribbon Ribbon提供了轮询、随机两种负载均衡算法（默认是轮询）可以实现从地址列表中使用负载均衡算法获取地址进行服务调用。 9.1Ribbon应用 在实例化RestTemplate的时候使用@LoadBalanced，服务地址直接可以使用服务名。 10.熔断器Hystrix（豪猪） Hystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败。 10.1线程隔离&amp;服务降级 Hystrix解决雪崩效应： 线程隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间。 服务降级：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞。 小结： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断 降级逻辑 12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(&quot;/consumer&quot;)@Slf4j@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)public class ConsumerController { @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @GetMapping(&quot;/{id}&quot;) //@HystrixCommand(fallbackMethod = &quot;queryByIdFallback&quot;) @HystrixCommand public String queryById(@PathVariable Long id){ /*String url = &quot;http://localhost:9091/user/&quot;+id; //获取eureka中注册的user-service的实例 List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(&quot;user-service&quot;); ServiceInstance serviceInstance = serviceInstances.get(0); url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/user/&quot; + id;*/ String url = &quot;http://user-service/user/&quot; + id; return restTemplate.getForObject(url, String.class); } public String queryByIdFallback(Long id){ log.error(&quot;查询用户信息失败。id：{}&quot;, id); return &quot;对不起，网络太拥挤了！&quot;; } public String defaultFallback(){ return &quot;默认提示：对不起，网络太拥挤了！&quot;; }} 修改超时配置 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 10.2服务熔断 ​ 在服务熔断中，使用的熔断器，也叫断路器，其英文单词为：Circuit Breaker ​ 熔断机制与家里使用的电路熔断原理类似；当如果电路发生短路的时候能立刻熔断电路，避免发生灾难。在分布式系 统中应用服务熔断后；服务调用方可以自己进行判断哪些服务反应慢或存在大量超时，可以针对这些服务进行主动熔 断，防止整个系统被拖垮。 ​ Hystrix的服务熔断机制，可以实现弹性容错；当服务请求情况好转之后，可以自动重连。通过断路的方式，将后续 请求直接拒绝，一段时间（默认5秒）之后允许部分请求通过，如果调用成功则回到断路器关闭状态，否则继续打 开，拒绝请求的服务。 Hystrix的熔断状态机模型： 状态机有3个状态： Closed：关闭状态（断路器关闭），所有请求都正常访问。 Open：打开状态（断路器打开），所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百 分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。 Half Open：半开状态，不是永久的，断路器打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开 状态。此时会释放部分请求通过，若这些请求都是健康的，则会关闭断路器，否则继续保持打开，再次进行休 眠计时。 11.服务消费者（Feign） 11.1简介 ​ Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 简而言之： Feign 采用的是基于接口的注解 Feign 整合了ribbon，具有负载均衡的能力 整合了Hystrix，具有熔断的能力 12.断路器（Hystrix） ​ 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 12.1断路器简介 ​ Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.Netflix. 开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的。较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。 13.路由网关(zuul) ​ Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。 zuul有以下功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 服务过滤 filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 14.分布式配置中心(Spring Cloud Config) ​ 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 15. 高可用的分布式配置中心(Spring Cloud Config) ​ 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用 16.消息总线(Spring Cloud Bus) ​ Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。【修改配置文件，无需重启】 准备：安装rabbitMq 17.服务链路追踪(Spring Cloud Sleuth) ​ 微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。 术语 Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。 Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。 Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束 cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化： 18.高可用的服务注册中心 ​ 服务注册中心Eureka Server，是一个实例，当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这篇文章主要介绍怎么将Eureka Server集群化。Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。 参考文献：黑马课程笔记，方志朋的博客","link":"/2021/02/25/Draft/2021/SpringCloud/"},{"title":"魑魅先生 | 计算机网络","text":"1. 网络层次划分 OSI/RM模型（Open System Interconnection/Reference Model）开放系统互联参考模型 2. OSI七层网络模型 OSI七层网络模型 1）物理层（Physical Layer） · 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。两个重要的设备名称，中继器（Repeater，放大器），集线器。 2）数据链路层（Data Link Layer） · 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 · 有关数据链路层的重要知识点：1&gt; 数据链路层为网络层提供可靠的数据传输；2&gt; 基本数据单位为帧；3&gt; 主要的协议：以太网协议；4&gt; 两个重要设备名称：网桥和交换机。 3）网络层（Network Layer） · 实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是&quot;路径选择、路由及逻辑寻址&quot;。网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。 · 具体的协议我们会在接下来的部分进行总结，有关网络层的重点为： 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议： IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 4&gt; 重要的设备：路由器。 4）传输层（Transport Layer） · 第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 · 重点：1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；3&gt; 重要设备：网关。 5）会话层 · 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 6）表示层 · 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 7）应用层 · 为操作系统或网络应用程序提供访问网络服务的接口。 · 会话层、表示层和应用层重点： · 1&gt; 数据传输基本单位为报文； · 2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 3. IP地址 1）网络地址 IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 2）广播地址 广播地址通常称为直接广播地址，是为了区分受限广播地址。 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 3）组播地址 D类地址就是组播地址。 先回忆下A，B，C，D类地址吧： A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31) B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 4）255.255.255.255 该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 5）0.0.0.0 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 6）回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 7）A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 4. 子网掩码及网络划分 随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。什么是子网掩码？子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。在计算子网掩码时，我们要注意IP地址中的保留地址，即&quot; 0&quot;地址和广播地址，它们是指主机地址或网络地址全为&quot; 0&quot;或&quot; 1&quot;时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。子网掩码的计算：对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。 下面总结一下有关子网掩码和网络划分常见的面试考题： 1）利用子网数来计算 · 在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。(1) 将子网数目转化为二进制来表示;如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；(2) 取得该二进制的位数，为N；该二进制为五位数，N = 5(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0 2）利用主机数来计算 · 如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：(1) 将主机数目转化为二进制来表示；700=1010111100(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；该二进制为十位数，N=10；(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。 3）根据每个网络的主机数量进行子网地址的规划和计算子网掩码 · 这也可按上述原则进行计算。比如一个子网有10台主机，那么对于这个子网需要的IP地址是：10＋1＋1＋1＝13注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。 5. ARP/RARP协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01； 主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02； 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： · （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。 · （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。 · （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 · （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 · （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。 RARP协议工作流程： · （1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； · （2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； · （3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用； · （4）如果不存在，RARP服务器对此不做任何的响应； 6. 路由选择协议 常见的路由选择协议有：RIP协议、OSPF协议。RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 7. TCP/IP协议 TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用&quot;带重传的肯定确认&quot;技术来实现传输的可靠性。TCP还采用一种称为&quot;滑动窗口&quot;的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 TCP报文首部格式：件）、HTTP协议等。 TCP协议的三次握手和四次挥手： 注：seq:&quot;sequance&quot;序列号；ack:&quot;acknowledge&quot;确认号；SYN:&quot;synchronize&quot;请求同步标志；；ACK:&quot;acknowledge&quot;确认标志&quot;；FIN：&quot;Finally&quot;结束标志。 TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。&quot;，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！为什么要三次握手？在只有两次&quot;握手&quot;的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，&quot;三次握手&quot;很有必要！为什么要四次挥手？试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮 8. UDP协议 UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：（1）源端口号；（2）目标端口号；（3）数据报长度；（4）校验值。使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 9. DNS协议 DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 10. NAT协议 NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 11. DHCP协议 DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 12. HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？GET：请求读取由URL所标志的信息。POST：给服务器添加信息（如注释）。PUT：在给定的URL下存储一个文档。DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别1）Get是从服务器上获取数据，Post是向服务器传送数据。2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 13. 一个举例 在浏览器中输入 http://www.baidu.com/ 后执行的全部过程。现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com， 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 14.TCP三次握手/四次挥手","link":"/2021/02/25/Draft/2021/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"RabbitMQ","text":"RabbitMQ 优势： 应用解耦，提升容错性和可维护性 异步提速，提升用户体验，系统吞吐量 削峰填谷，提高系统稳定性、 劣势： 可用性降低（保证MQ没问题） 系统复杂度提高（不被重复消费，保证消息顺序） 一致性问题 使用条件: 生产者不需要从消费者处获得反馈 容许短暂的不一致性 确实用了有效果 常见MQ产品 RabbitMQ简介 RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：http://www.rabbitmq.com/ RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）； 官网对应模式介绍：https://www.rabbitmq.com/getstarted.html RabbitMQ 安装配置 注意: 请使用资料里提供的CentOS-7-x86_64-DVD-1810.iso 安装虚拟机. 1. 安装依赖环境 在线安装依赖环境： 12yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz 2. 安装Erlang 上传 erlang-18.3-1.el7.centos.x86_64.rpm socat-1.7.3.2-5.el7.lux.x86_64.rpm rabbitmq-server-3.6.5-1.noarch.rpm 123# 安装rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm 如果出现如下错误 说明gblic 版本太低。我们可以查看当前机器的gblic 版本 1strings /lib64/libc.so.6 | grep GLIBC 当前最高版本2.12，需要2.15.所以需要升级glibc 使用yum更新安装依赖 1sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y 下载rpm包 1234567wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &amp; 安装rpm包 1sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps 安装完毕后再查看glibc版本,发现glibc版本已经到2.17了 1strings /lib64/libc.so.6 | grep GLIBC 3. 安装RabbitMQ 123456# 安装rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm# 安装rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm 4. 开启管理界面及配置 123456# 开启管理界面rabbitmq-plugins enable rabbitmq_management# 修改默认配置信息vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app # 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest 5. 启动 123456service rabbitmq-server start # 启动服务service rabbitmq-server stop # 停止服务service rabbitmq-server restart # 重启服务service iptables stop#关闭防火墙systemctl stop firewalld #conos7关闭防火墙方法 设置配置文件 1234cd /usr/share/doc/rabbitmq-server-3.6.5/cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config 6. 配置虚拟主机及用户 6.1. 用户角色 RabbitMQ在安装好后，可以访问http://ip地址:15672 ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作： 角色说明： 1、 超级管理员(administrator) 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 2、 监控者(monitoring) 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 3、 策略制定者(policymaker) 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 4、 普通管理者(management) 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。 5、 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 6.2. Virtual Hosts配置 像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。 6.2.1. 创建Virtual Hosts 6.2.2. 设置Virtual Hosts权限 入门程序 生产者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.lxl.producer;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer_HelloWord { public static void main(String[] args) throws IOException, TimeoutException { //1.创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); //2. 设置参数 factory.setHost(&quot;126.11.41.128&quot;);//ip 默认值 localhost factory.setPort(5672); //端口 默认值 5672 factory.setVirtualHost(&quot;/lxlv&quot;);//虚拟机 默认值/ factory.setUsername(&quot;lxl&quot;);//用户名 默认 guest factory.setPassword(&quot;lxl&quot;);//密码 默认值 guest //3. 创建连接 Connection Connection connection = factory.newConnection(); //4. 创建Channel Channel channel = connection.createChannel(); //5. 创建队列Queue /* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1. queue：队列名称 2. durable:是否持久化，当mq重启之后，还在 3. exclusive： * 是否独占。只能有一个消费者监听这队列 * 当Connection关闭时，是否删除队列 * 4. autoDelete:是否自动删除。当没有Consumer时，自动删除掉 5. arguments：参数。 */ //如果没有一个名字叫hello_world的队列，则会创建该队列，如果有则不会创建 channel.queueDeclare(&quot;hello_world&quot;,true,false,false,null); /* basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) 参数： 1. exchange：交换机名称。简单模式下交换机会使用默认的 &quot;&quot; 2. routingKey：路由名称 3. props：配置信息 4. body：发送消息数据 */ String body = &quot;hello rabbitmq~~~&quot;; //6. 发送消息 channel.basicPublish(&quot;&quot;,&quot;hello_world&quot;,null,body.getBytes()); //7.释放资源// channel.close();// connection.close(); }} 消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.lxl.consumer;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer_HelloWorld { public static void main(String[] args) throws IOException, TimeoutException { //1.创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); //2. 设置参数 factory.setHost(&quot;126.11.41.128&quot;);//ip 默认值 localhost factory.setPort(5672); //端口 默认值 5672 factory.setVirtualHost(&quot;/lxlv&quot;);//虚拟机 默认值/ factory.setUsername(&quot;lxl&quot;);//用户名 默认 guest factory.setPassword(&quot;lxl&quot;);//密码 默认值 guest //3. 创建连接 Connection Connection connection = factory.newConnection(); //4. 创建Channel Channel channel = connection.createChannel(); //5. 创建队列Queue /* queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) 参数： 1. queue：队列名称 2. durable:是否持久化，当mq重启之后，还在 3. exclusive： * 是否独占。只能有一个消费者监听这队列 * 当Connection关闭时，是否删除队列 * 4. autoDelete:是否自动删除。当没有Consumer时，自动删除掉 5. arguments：参数。 */ //如果没有一个名字叫hello_world的队列，则会创建该队列，如果有则不会创建 channel.queueDeclare(&quot;hello_world&quot;,true,false,false,null); /* basicConsume(String queue, boolean autoAck, Consumer callback) 参数： 1. queue：队列名称 2. autoAck：是否自动确认 3. callback：回调对象 */ // 接收消息 Consumer consumer = new DefaultConsumer(channel){ /* 回调方法，当收到消息后，会自动执行该方法 1. consumerTag：标识 2. envelope：获取一些信息，交换机，路由key... 3. properties:配置信息 4. body：数据 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(&quot;consumerTag：&quot;+consumerTag); System.out.println(&quot;Exchange：&quot;+envelope.getExchange()); System.out.println(&quot;RoutingKey：&quot;+envelope.getRoutingKey()); System.out.println(&quot;properties：&quot;+properties); System.out.println(&quot;body：&quot;+new String(body)); } }; channel.basicConsume(&quot;hello_world&quot;,true,consumer); //关闭资源？不要 }} RabbitMQ运转流程 在入门案例中： 生产者发送消息 生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker； 声明队列并设置属性；如是否排它，是否持久化，是否自动删除； 将路由键（空字符串）与队列绑定起来； 发送消息至RabbitMQ Broker； 关闭信道； 关闭连接； 消费者接收消息 消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker 向Broker 请求消费相应队列中的消息，设置相应的回调函数； 等待Broker回应闭关投递响应队列中的消息，消费者接收消息； 确认（ack，自动确认）接收到的消息； RabbitMQ从队列中删除相应已经被确认的消息； 关闭信道； 关闭连接； 生产者流转过程说明 客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 消费者流转过程说明 消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。 在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。 Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。 消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 RabbitMQ工作队列模式 模式说明（只有一盒糖你们几个抢） Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。 应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 代码 Work Queues与入门程序的简单模式的代码是几乎一样的；可以完全复制，并复制多一个消费者进行多个消费者同时消费消息的测试。 生产者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.rabbitmq.work;import com.itheima.rabbitmq.util.ConnectionUtil;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Producer { static final String QUEUE_NAME = &quot;work_queue&quot;; public static void main(String[] args) throws Exception { //创建连接 Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(QUEUE_NAME, true, false, false, null); for (int i = 1; i &lt;= 30; i++) { // 发送信息 String message = &quot;你好；小兔子！work模式--&quot; + i; /** * 参数1：交换机名称，如果没有指定则使用默认Default Exchage * 参数2：路由key,简单模式可以传递队列名称 * 参数3：消息其它属性 * 参数4：消息内容 */ channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot;已发送消息：&quot; + message); } // 关闭资源 channel.close(); connection.close(); }} 消费者1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.itheima.rabbitmq.work;import com.itheima.rabbitmq.util.ConnectionUtil;import com.rabbitmq.client.*;import java.io.IOException;public class Consumer1 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //一次只能接收并处理一个消息 channel.basicQos(1); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { try { //路由key System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey()); //交换机 System.out.println(&quot;交换机为：&quot; + envelope.getExchange()); //消息id System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag()); //收到的消息 System.out.println(&quot;消费者1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;)); Thread.sleep(1000); //确认消息 channel.basicAck(envelope.getDeliveryTag(), false); } catch (InterruptedException e) { e.printStackTrace(); } } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.QUEUE_NAME, false, consumer); }} 消费者2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.itheima.rabbitmq.work;import com.itheima.rabbitmq.util.ConnectionUtil;import com.rabbitmq.client.*;import java.io.IOException;public class Consumer2 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //一次只能接收并处理一个消息 channel.basicQos(1); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { try { //路由key System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey()); //交换机 System.out.println(&quot;交换机为：&quot; + envelope.getExchange()); //消息id System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag()); //收到的消息 System.out.println(&quot;消费者2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;)); Thread.sleep(1000); //确认消息 channel.basicAck(envelope.getDeliveryTag(), false); } catch (InterruptedException e) { e.printStackTrace(); } } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.QUEUE_NAME, false, consumer); }} 测试 启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息。 小结 在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。 Publish/Subscribe发布与订阅模式 在订阅模型中，多了一个 Exchange 角色，而且过程略有变化： lP：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） lC：消费者，消息的接收者，会一直等待消息到来 lQueue：消息队列，接收消息、缓存消息 lExchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： ØFanout：广播，将消息交给所有绑定到交换机的队列 ØDirect：定向，把消息交给符合指定routing key 的队列 ØTopic：通配符，把消息交给符合routing pattern（路由模式） 的队列 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！ Routing路由工作模式 模式说明： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key） l消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey lExchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息 lP：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key lX：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列 lC1：消费者，其所在队列指定了需要 routing key 为 error 的消息 lC2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息 Routing 模式要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列 Topics通配符工作模式 Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： #：匹配一个或多个词 *：匹配不多不少恰好1个词 举例： item.#：能够匹配item.insert.abc 或者 item.insert item.*：只能匹配item.insert 图解： 红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到 黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配 Spring-RabbitMQ SpringBoot-RabbitMQ RabbitMQ高级特性 1.1消息可靠投递 confirm确认模式 【消息从producer到exchange会返回一个confirmCallback】 return退回模式 【消息从producer到queue失败则会返回一个returnCallback】 rabbitmq整各消息投递的路径为： profucer-----》rabbitmq broker----》exchange-----》queue----》consumer 设置ConnectionFactory的publisher-confirm=&quot;true&quot; 开启确认模式 使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断true，则发送成功，反之失败，需要处理 设置ConnectionFactory的publisher-returns=&quot;true&quot; 开启退回模式 使用rabbitTemplate.setReturnCallback设置回调函数。当消息从exchange路由到queue失败后，如果设置了rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。 在RabbitMQ中也提供了事物机制，但是性能较差。 1.2Consumer ACK ack指acknowledge，确认。表示消费端收到消息后的确认方式 三种确认方式： ​ 自动确认：acknowledge=&quot;none&quot; ​ 手动确认：acknowledge=&quot;manual&quot; ​ 根据异常情况确认：acknowledge=&quot;auto&quot; ​ 自动确认消息被consumer接收到，则自动确认，并将响应message从缓存中移除，实际业务中小细节受到，业务出现异常，那么消息会丢失，如果是设置的手动确认方式，则需要业务处理成功后，调用channel.basicAck(),手动签收，如果出现异常，则调用channel.basicNack（）方法，让其自动重发消息。 1.3消费端限流 1.4TTL 1234567* TTL:过期时间* 1. 队列统一过期* 2. 消息单独过期** 如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准。* 队列过期后，会将队列所有消息全部移除。* 消息过期后，只有消息在队列顶端，才会判断其是否过期(移除掉) 1.5死信队列 死信队列（DXL）。Dead Letter Exchange（死信队列交换机），当消息成为Dead Message后，可以被重新发送到另外一个交换机，这个交换机就是DEX。 问题： 1.消息什么时候成为死信? 消息成为死信的三种情况： 1.队列消息的长度达到限制 2.消费者拒收消费消息，basicNack/basicReject，并且不把消息重新放入原目标队列，requeue=false 3.原队列存在消息过期设置，消息达超时间未被消费； 2.队列如何与DEX绑定？ 1.6延迟队列 消息进入队列后不会被立即被消费，只有达到指定时间后，才会被消费。 需求： ​ 1.下单后三十分钟未支付，取消订单，回滚库存 ​ 2.新用户注册7天后，发送短信问候 实现方式 ​ 1.定时器（有延迟，对数据库有影响） ​ 2.延迟队列（MQ中未直接提供延迟队列，DLX+TTL实现） 参考文献：黑马视频相关笔记","link":"/2021/03/24/Draft/2021/RabbitMQ/"},{"title":"信息系统项目管理师","text":"教材准备，视频一套，历年真题 工具：平板勾划PPT，电脑Markdown同时记下重要的相关笔记 准备：江山老师（视频），十大管理（打印），历年真题答案（） 技巧：多口诀，&quot;不择手段记忆&quot;，论文字要练，错不涂，十大管理要滚瓜烂熟，速看视频，适当笔记记忆，做题对应细化，论文提前准备 考试介绍，学习方法，重难点，10大知识域概述 考试介绍 通过考试相当于拿到高级职称，难度上午大于论文大于案例。 作用 方法 重视基础（上午），考哪里学哪里，重视真题，费曼学习法，艾宾浩斯记忆，利用碎片时间，考上决心，2/8法则，PDCA循环，人机料法环，无事不项目 狗（沟通）子（质量）整（整体）范（范围）进（进度），成（成本）人（人力资源，干系人）风（风险）采（采购） 所有管理的综合性管理 三从 从过程想结果，从结果知输入，从输入选工具 四得 一得文件计划；二得成果数据；三得变更请求；四的因素资产 共性总结 1、上一个过程的输出大部分是下一个过程的输入 2、计划和文件是不一样的（每个输入都有计划和文件） 3、被批准的变更请求约等于计划 4、在执行和监控过程产生新的变更请求（变更请求包括变什么和怎么变，这是变更请求和纠正、预防、缺陷修复的关系） 5、执行过程产生工作绩效数据---数据+背景在监控过程组成为了工作绩效信息然后输出工作绩效报告注意工作绩效数据是执行过程的输出→那么就是监控的输入→监控的输出就成了工作绩效信息 6、通过过程的含义记忆每个过程组最主要的成果（输出）！ 7、监控过程组每个过程都有计划+工作绩效报告要记住我说的监控的那些原理 跟踪进展→拿着计划的这把尺子测量实际的工作绩效报告→偏差计算→偏差评估、分析是否变更→预测 →趋势分析 8、项目管理计划和其它子计划（范围管理计划、进度管理计划、质量管理计划等）区别和联系下面以项目管理计划和其中一个子计划为例子总结规律如下：了解后对其它过程帮助甚多 （1）当子计划或基准是主要的输入时→专门列出（如定义范围、收集需求等过程） （2）当子计划或基准是首次输出时→专门列出（如范围管理计划），以后的输出都以“项目管理计划更新”的形式出现 （3）子计划或基准是作为输出时候→项目管理计划将作为输入（如规划范围管理） （4）对控制过程组来说，输入和输出都是项目管理计划而不是具体的子计划 重点，十大管理 1.论文写作基本介绍 ​ 二选一，两小时，注意写字整洁。2500左右 摘要300 正文2000。 ​ 学好理论，写字速度整洁，多看范文，选定素材，别写具体项目名称。 2.信息化与信息系统 网络 物数网传会表应 OSI/RM（Open System Interconnection/Reference Model，开放系统互连参考模型） 物理层：比特，串行传输。数据链路层：帧。网络层：分组，处理与寻址和传输有关的管理问题，提供点对点的连接。传输层：报文，建立、维护和撤销传输连接（端对端的连接），并进行流量控制和差错控制。 测试，软件需求，生命周期，面向对象，中间件，新网络技术 UML，测试 重点 新一代信息技术（英语单词），物联网，大数据，云计算，移动互联网，智慧城市，互联网+（互联网+各种传统行业），智能制造2025，AR，VR，AI，区块链，特别联网，5G，华为鸿蒙麒麟，一带一路，两化融合 信息安全技术 3.信息系统项目管理基础 项目特点：（1）临时性：有明确的开始和结束时间。 （2）独特性：世上没有两个完全相同的项目。 （3）渐进明细性：前期只能粗略定义，然后逐渐明朗、完善和精确，这也就意味着变更不可避免，所以要控制变更。 **项目的组织方式：**职能型、项目型、矩阵型 4.立项管理 2 （一个项目从提出申请到批准立项）招投标，合同，采购 项目建议书（立项申请)主要内容：项目的必要性、项目的市场预测、产品方案或服务的市场预测、项目建设必需的条件等 计算: 利率 利率有单利和复利，单利息=本金×利率×期限，F=P×（1+i）n F：复利终值 P：本金 i：利率 N：利率获取时间的整数倍 净现值（Net Present Value，NPV） 净现值大于零则方案可行，且净现值越大，方案越优，投资效益越好。 NPV 的计算步骤如下： （1）根据项目的资本结构设定项目的折现率。 （2）计算每年项目现金流量的净值。 （3）根据设定的折现率计算每年的净现值。 （4）将净现值累加起来。 净现值率 净现值率（NPVR）=项目的净现值（NPV）/原始投资的现值合计 投资回收期 招标 招标（招标公告，招标文件，） 中标通知书发出之日起三十日内应当签订合同，截止时间15日前进行必要的澄清或者修改，招标人应当确定投标人编制投标文件所需要的合理时间。但是，依法必须进行招标的项目，自招标文件开始发出之日起至投标人提交投标文件截止之日止，最短不得少于20日。 投标 投标人少于三个的，招标人应当重新招标。在招标文件要求提交投标文件的截止时间后送达的投标文件，招标人应当拒收。 开标 开标应当在招标文件确定的提交投标文件截止时间的同一时间公开进行。开标地点应当为招标文件中预先确定的地点。开标由招标人主持，邀请所有投标人参加。 评标 评标委员会由招标人的代表和有关技术、经济等方面的专家组成，成员人数为5人以上单数，其中技术、经济等方面的专家不得少于成员总数的三分之二。 中标 中标通知书发出后，招标人改变中标结果的，或者中标人放弃中标项目的，应当依法承担法律责任。 合同 分类： 范围：项目总承包合同、项目单项承包合同、项目分包合同。 付款方式：项目总价合同、项目单价合同、项目成本加酬金合同 合同的主要内容包括：项目名称；标的内容和范围；项目的质量要求：通常情况下采用技术指标限定等各种方式来描述信息系统工程的整体质量标准以及各部分质量标准，它是判断整个工程项目成败的重要依据；项目的计划、进度、地点、地域和方式；项目建设过程中的各种期限；技术情报和资料的保密；风险责任的承担；技术成果的归属；验收的标准和方法；价款、报酬（或使用费）及其支付方式；违约金或者损失赔偿的计算方法；解决争议的方法：该条款中应尽可能地明确在出现争议与纠纷时采取何种方式来协商解决；名词术语解释等 8.整体管理 ITO ITO 名称及定义 输入 工具技术 输出 项目章程 正式批准一个项目的文档，制定项目的头（项目经理） 项目工作说明书商业论证协议事业环境因素组织过程资产 专家判断引导技术 项目章程 制定项目管理计划 包括定义、准备和协调所有构成计划，形成项目管理计划所必要的行动 项目章程其他过程输入【项目初步范围说明书，管理过程，预测，工作绩效信息】事业环境因素组织过程资产 专家判断引导技术 项目管理计划 指导与管理项目工作 提意见，记考核，做东西 项目管理计划，批准的变更请求，事业环境因素，组织过程资产 专家判断项目管理信息系统会议 可交付成果工作绩效数据变更请求项目管理计划更新项目文件更新 监控项目工作 从项目开始到结束，收集，测量发布绩效信息，及评估会影响过程改进的度量项和趋势 项目管理计划事业环境因素组织过程资产进度预测成本预测确认的变更工作绩效信息 专家判断分析技术项目管理信息系统【PMIS】会议 变更请求工作绩效报告项目管理计划更新项目文件更新 实施整体变更控制 审批变更，项目经理付最终责任 变更请求，工作绩效报告，变更请求，项目管理计划，事业环境因素，组织过程资产 专家判断会议变更控制工具 批准的变更请求变更日志项目管理计划更新项目文件更新 项目收尾 打包交货 项目管理计划验收的可交付成果组织过程资产 专家判断分析技术会议 最终产品、服务或成果移交组织过程资产更新 9.范围管理 ITO ITO 名称及定义 输入 工具技术 输出 10.进度管理 ITO ITO 名称及定义 输入 工具技术 输出 11.成本管理 ITO ITO 名称及定义 输入 工具技术 输出 挣值分析计算 12.质量管理 ITO ITO 名称及定义 输入 工具技术 输出 13.人力资源管理 ITO ITO 名称及定义 输入 工具技术 输出 14.干系人管理 ITO ITO 名称及定义 输入 工具技术 输出 15.沟通管理 ITO ITO 名称及定义 输入 工具技术 输出 16.风险管理 ITO ITO 名称及定义 输入 工具技术 输出 17.采购管理 ITO ITO 名称及定义 输入 工具技术 输出 PPT加星看了就可以了 18.合同管理 上午一分 合同的分类 19.信息文档和配置管理 上午2分 文档分类（开发，产品，管理） 上午一般三分 20.20-28章 知识管理 显性知识，隐性知识,隐性知识分享途经，知识产权保护，软件著作权 战略管理 组织战略因素组成，战略实施，类型层次，平衡计分卡 组织级项目管理 流程管理 项目集，项目组合管理 信息安全管理 综合测试管理、量化项目管理，成熟度模型 CMMI（能力成熟度模型）、 法律法规 合同法 1 合同内容，要约，标的，格式（非格式【手写】）条款，违心合同， 招标法 1 必须进行招标的项目、标底（必须保密） 著作权法 政府采购法 2 常用技术标准 2-3 软件工程国家标准GB/T11457-2006（审计-代码审记-配置审计-认证-走查-鉴定-基线-配置控制委员会-配置状态报告-设计评审-桌面检查-评价-故障-功能配置审计） 软件生存周期的过程，软件生命周期各阶段与软件文档编制工作的关系，各类人员与软件文档的使用关系，软件产品质量，6个质量特性21个质量子特性 案例分析 五种题型 问答题，计算题，分析题，理论题，填空，选择，判断题 分析题 回答简练，文字工整清晰，答题有序，多写不扣分，专业化 万金油： 技术出身：开发和管理所需技能不同，需要培训 身兼数职：导致没时间去学习管理知识，工作负荷过载，身心疲惫，全局影响 新技术：风险，需培训，学习，监控技术风险，找到合适的人，实在不行外包 有人对项目不满意：简历有效沟通机制方式发法，缺乏有效的项目绩效管理机制，需加强沟通 变更：书面申请，审批确认，跟踪变更缺一不可 客户验收不通过：说明验收标准没有得到认可确认，没有验收测试规范和方法 愚人有关问题：沟通不到位 过一段时间才发现问题：监控不力 里程碑，时间紧促：没有冗余考虑风险的想法 外部因素导致延工：没有考虑外在因素影响，变更5个理由 争执：沟通问题，计划不够周明 多头汇报：项目章程，多头汇报导致信息沟通不畅通或产生冲突 知识点 如何缩短活动的工期，成本控制，质量新老7工具，提升项目质量， 计算 进度类 总时差 是指在不延误项目完成日期或违反进度因素的前提下，某活动可以推迟的时间。 总时差=LS-ES=LF-EF 自由时差 是指在不影响紧后活动最早开始的情况下，当前活动可以推迟的时间。 自由时差=(后一活动)ES-(前一活动的)EF 所以总时差影响总工期，自由时差影响紧后活动。 （1）总时差（TF）：当一项活动的最早开始时间和最迟开始时间不相同时，它们之间的差值是该工作的总时差。计算公式是：TF=LS-ES。 （2）自由时差（FF）：在不影响紧后活动完成时间的条件下，一项活动可能被延迟的时间是该项活动的自由时差，它由该项活动的最早完成时间EF和它的紧后活动的最早开始时间决定的。计算公式是：FF=min{紧后活动的ES}-EF。 （3）关键路径。项目的关键路径是指能够决定项目最早完成时间的一系列活动。它是网络图中的最长路径，具有最少的时差。在实际求关键路径时，一般的方法是看哪些活动的总时差为0，总时差为0的活动称为关键活动，关键活动组成的路径称为关键路径。 尽管关键路径是最长的路径，但它代表了完成项目所需的最短时间。因此，关键路径上各活动持续时间（历时）的和就是项目的计算工期。 最早开始时间（ES）： 一项活动的最早开始时间取决于它的所有紧前活动的完成时间。通过计算到该活动路径上所有活动的完成时间的和，可得到指定活动的ES。如果有多条路径指向此活动，则计算需要时间最长的那条路径，即ES=max{紧前活动的EF}。 最早结束时间（EF）： 一项活动的最早完成时间取决于该工作的最早开始时间和它的持续时间（D），即EF=ES+D。 最晚结束时间（LF）： 在不影响项目完成时间的条件下，一项活动可能完成的最迟时间。计算公式是：LF=min{紧后活动的LS}。 最晚开始时间（LS）： 在不影响项目完成时间的条件下，一项活动可能开始的最晚时间。计算公式是：LS=LF-D。 前推法来计算最早时间 某一活动的最早开始时间（ES）=指向它的所有紧前活动的最早结束时间的最大值。 某一活动的最早结束时间（EF）=ES+T（作业时间） 逆推法来计算最迟时间 某一活动的最迟结束时间（LF）=指向它的所有紧后活动的最迟开始时间的最小值。 某一活动的最迟开始时间（LS）=LF-T（作业时间） 计算关键路径的步骤 **1. 用有方向的线段标出各结点的紧前活动和紧后活动的关系，使之成为一个有方向的网络图（PDM） \\2. 用正推和逆推法计算出各个活动的ES,LS, EF, LF，并计算出各个活动的自由时差。找出所有总时差为零或为负的活动，就是关键活动 \\3. 关键路径上的活动持续时间决定了项目的工期，总和就是项目工期。 **自由时差 ** 计算公式： 自由时差=所有紧后工作中最早开始时间最小值－ 最早结束时间 **总时差 ** 计算公式： 总时差=最迟开始时间-最早开始时间=最迟结束时间-最早结束时间 单代号网络图 双代号网络图 双代号时标网络图 全为实线的为关键路径， 成本类 挣值分析 PV [Planned Value]计划值：应该完成多少工作？ 要干的活 EV [Earned Value]挣值：完成了多少预算工作？ 干完的活 AC [Actual Cost]实际成本：完成工作的实际成本是多少？ 实际花费 BAC [Budget cost at completion] 基线预算成本：全部工作的预算是多少？不改变成本基准，BAC就不会发生变化 CV [Cost Variance] 成本偏差 CV＝EV－AC，CV&gt;0，成本节约，CV&lt;0，成本超支。 SV [Schedule Variance] 进度偏差 SV＝EV－PV，SV&gt;0，进度超前，SV&lt;0，进度落后。 CPI [Cost Performance Index] 成本执行指数CPI＝EV/AC，CPI＝1，资金使用效率一般；CPI&gt;1成本节约，资金使用效率高；CPI&lt;1，成本超支，资金使用效率低。 SPI [Schedule Performance Index] 进度执行指数 SPI＝EV/PV，SPI＝1，进度与计划相符，SPI&gt;1，进度超前，SPI&lt;1，进度落后。 ETC [Estimate (or Estimated) To Complete] 完工时尚需成本估算：到完成时，剩余工作量还需要多少成本,ETC也就是估计完成项目的剩余工作成本 BAC [Budget cost at completion] 完工预算：全部工作的预算是多少？不改变成本基准，BAC就不会发生变化 EAC [Estimate at completion] 完成预估：全部工作的成本是多少？是根据项目的绩效和风险量化对项目最可能的总成本所做的一种预测。 完工工期估算=预算工期/SPI 预测EAC 与 ETC： 由于存在成本偏差情况，所以在典型偏差与非典型偏差时，计算顺序不一样，如下: 典型偏差：未来项目的CPI、SPI会保持不变，此时预测项目完成时的总成本和预计完成时间，应该用典型偏差公式。 EAC= AC+(BAC-EV) =BAC/CPI ETC=EAC-AC 非典型偏差：非典型偏差的含义是项目未来的工作绩效与当前无关，和原计划保持一样，即项目未来的成本绩效指数和进度绩效指数都是“1”）需要纠偏 ETC=BAC-EV 基线总成本-已挣得部份 EAC=ETC+AC 上午小计算 盈亏平衡点 决策树计算 资源平衡问题 统计抽样问题 自制\\外购分析 沟通渠道数 [n(n-1)]/2 风险曝光度 现值 净现值，投资回收期 运筹学 计算量大 求最短和最长路径 线性规划问题 投资收益最大问题 更换设备问题 车床铣床问题 流量问题 人员分配问题【矩阵法（行列分别减一次最小值，根据行零个数从少到多分配）】 伏格尔方法解传输问题 论文 提前准备，摘要300内，正文不少于2000，字迹清晰，无需写题目 准备一个项目（投标书，方案书） 准备框架 自己写一个","link":"/2021/03/29/Draft/2021/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"},{"title":"魑魅先生 | 设计模式","text":"学习目的：增加系统的健壮性，易修改性和可扩展性，阅读源码的通用工具，通用问题的工具箱，程序员的通用语言 学习方法:视频引入，博客弥补，书籍细化，代码实践 学习资源：大话设计模式书籍，bili视频，博客1,博客2 学习目标程度：了解即可 设计模式原则 开闭原则 ：对修改关闭，对扩展开放 由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放， 而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改， 如果只增加代码就完成了新功能，那是最好的。一个类从头到尾都是自己写的可以更改，别人的要符合开闭原则 依赖倒转原则 ：针对接口和抽象编程 上层（调用别的方法的）不能依赖于下层（方法被调用的），他们都应该依赖于抽象 合成复用原则 ：多用组合少用继承 继承（实线空箭头） 依赖 关联（实线箭头）：组合（实心菱形加箭头）（鸟和翅膀）；聚合（空心菱形加箭头）（雁和雁群） 迪米特原则（最少知道原则） ：实体之间尽量少的相互作用 个对象应对其它对象尽可能少的了解，和朋友（类中字段，方法参数，方法返回值，方法实例出来的对象）通信 里式代换原则 ：基类可以出现的地方子类也可以出现。 里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则， 即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 重写时子类限制等级不能更高，错误不能抛出更多 单一职责原则 ：每个方法，类，框架只负责一件事 接口隔离原则 ：使用多个专门的接口比一个总接口好 ---分--- 学习设计模式，关键是学习设计思想，不能简单地生搬硬套， 也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性， 并意识到设计模式也并不是万能的。 算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。 意图 部分简单描述问题和解决方案。 动机 部分将进一步解释问题并说明模式会如何提供解决方案。 结构 部分展示模式的每个部分和它们之间的关系。 在不同语言中的实现 提供流行编程语言的代码， 让读者更好地理解模式背后的思想。 设计原则 一句话归纳 目的 开闭原则 对扩展开放，对修改关闭 降低维护带来的新风险 依赖倒置原则 高层不应该依赖低层，要面向接口编程 更利于代码结构的升级扩展 单一职责原则 一个类只干一件事，实现类要单一 便于理解，提高代码的可读性 接口隔离原则 一个接口只干一件事，接口要精简单一 功能解耦，高聚合、低耦合 迪米特法则 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 只和朋友交流，不和陌生人说话，减少代码臃肿 里氏替换原则 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 防止继承泛滥 合成复用原则 尽量使用组合或者聚合关系实现代码复用，少使用继承 降低代码耦合 学习进度 设计原则 开闭原则 里氏替换原则 依赖倒置原则 单一职责原则 接口隔离原则 迪米特法则 合成复用原则 行为模式 职责链模式（Chain of Responsibility）😎😎😎😎😎 命令模式（Command） 迭代器模式（Iterator） 调停者（中介者）模式（Mediator） 备忘录模式（Memento） 观察者模式（Observer） 状态模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 访问者模式（Visitor） 解释器模式（Interpreter） 结构型模式 适配器模式（Adapter） 桥接模式（Bridge） 组合模式（Composite） 装饰模式（Decorator） 外观模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 创建型模式 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 创建者（生成器）模式（Builder） 原型模式（Prototype） 单例模式（Singleton） 设计模式简述 模式之间的关系 Refactoringguru.cn 创建型模式 这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。 工厂方法Factory Method抽象工厂Abstract Factory生成器Builder原型Prototype单例Singleton 结构型模式 这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 适配器Adapter桥接Bridge组合Composite装饰Decorator外观Facade享元Flyweight代理Proxy 行为模式 这类模式负责对象间的高效沟通和职责委派。 责任链Chain of Responsibility命令Command迭代器Iterator中介者Mediator备忘录Memento观察者Observer状态State策略Strategy模板方法Template Method访问者Visitor 创建型模式 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 结构型模式 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 UML 工具：processon 方法和属性的访问权限 - private # protected + public ~ package private 关系 概览 继承 | 泛化【继承并特殊】 12【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。【箭头指向】：带三角箭头的实线，箭头指向父类 实现【接口全实现】 123【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现【箭头指向】：带三角箭头的虚线，箭头指向接口 关联【我知你些属】 1234【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者 聚合【一团分几个】 1234【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系.聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体 组合【一个切几个】 123【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。没有公司就不存在部门 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体 依赖【我要用你的】 12345【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖 设计模式重点详解 Mybatis（ 1、Builder模式5、组合模式9、迭代器模式2、工厂模式3、单例模式4、代理6、模板方法模式7、适配器模式8、装饰者模式） Spring（1.简单工厂2.工厂方法3.单例模式4.适配器模式5.装饰器模式6.代理模式7.观察者模式8.策略模式9.模版方法模式） 创建型模式 《单例模式Singleton》 特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点。 优点： 单例模式可以保证内存里只有一个实例，减少了内存的开销。 可以避免对资源的多重占用。 单例模式设置全局访问点，可以优化和共享资源的访问。 缺点： 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 单例模式的应用场景： 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 频繁访问数据库或文件的对象。 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。 分类JAVA实现： 懒汉式：类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例 ​ 如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。 123456789101112public class LazySingleton { private static volatile LazySingleton instance = null; //保证 instance 在所有线程中同步 private LazySingleton() { } //private 避免类在外部被实例化 public static synchronized LazySingleton getInstance() { //getInstance 方法前加同步 if (instance == null) { instance = new LazySingleton(); } return instance; }} 饿汉式：类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 12345678public class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton() { } public static HungrySingleton getInstance() { return instance; }} ​ 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。 《原型模式Prototype》 特点： 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。 原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 优点： Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。 深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化创建对象过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。 缺点： 需要为每一个类都配置一个 clone 方法 clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。 角色： 抽象原型类：规定了具体原型对象必须实现的接口。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 原型模式的应用场景： 对象之间相同或相似，即只是个别的几个属性不同的时候。 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。 JAVA实现： 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;interface Shape extends Cloneable { public Object clone(); //拷贝 public void countArea(); //计算面积}class Circle implements Shape { public Object clone() { Circle w = null; try { w = (Circle) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(&quot;拷贝圆失败!&quot;); } return w; } public void countArea() { int r = 0; System.out.print(&quot;这是一个圆，请输入圆的半径：&quot;); Scanner input = new Scanner(System.in); r = input.nextInt(); System.out.println(&quot;该圆的面积=&quot; + 3.1415 * r * r + &quot;\\n&quot;); }}class Square implements Shape { public Object clone() { Square b = null; try { b = (Square) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(&quot;拷贝正方形失败!&quot;); } return b; } public void countArea() { int a = 0; System.out.print(&quot;这是一个正方形，请输入它的边长：&quot;); Scanner input = new Scanner(System.in); a = input.nextInt(); System.out.println(&quot;该正方形的面积=&quot; + a * a + &quot;\\n&quot;); }}class ProtoTypeManager { private HashMap&lt;String, Shape&gt; ht = new HashMap&lt;String, Shape&gt;(); public ProtoTypeManager() { ht.put(&quot;Circle&quot;, new Circle()); ht.put(&quot;Square&quot;, new Square()); } public void addshape(String key, Shape obj) { ht.put(key, obj); } public Shape getShape(String key) { Shape temp = ht.get(key); return (Shape) temp.clone(); }}public class ProtoTypeShape { public static void main(String[] args) { ProtoTypeManager pm = new ProtoTypeManager(); Shape obj1 = (Circle) pm.getShape(&quot;Circle&quot;); obj1.countArea(); Shape obj2 = (Shape) pm.getShape(&quot;Square&quot;); obj2.countArea(); }} 《简单工厂模式Simple Factory Pattern》 特点： 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点 需要生成复杂对象的地方，都可以尝试考虑使用工厂模式。复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。 优点： 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。 客户端无需知道所创建具体产品的类名，只需知道参数即可。 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。 缺点： 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。 角色： 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。 简单工厂模式的应用场景： 生成复杂对象 JAVA实现 123456789101112131415161718192021222324252627282930313233343536public class Client { public static void main(String[] args) { } //抽象产品 public interface Product { void show(); } //具体产品：ProductA static class ConcreteProduct1 implements Product { public void show() { System.out.println(&quot;具体产品1显示...&quot;); } } //具体产品：ProductB static class ConcreteProduct2 implements Product { public void show() { System.out.println(&quot;具体产品2显示...&quot;); } } final class Const { static final int PRODUCT_A = 0; static final int PRODUCT_B = 1; static final int PRODUCT_C = 2; } static class SimpleFactory { public static Product makeProduct(int kind) { switch (kind) { case Const.PRODUCT_A: return new ConcreteProduct1(); case Const.PRODUCT_B: return new ConcreteProduct2(); } return null; } }} 《工厂模式Factory Pattern》 特点： 可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。 优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。 缺点： 类的个数容易过多，增加复杂度 增加了系统的抽象性和理解难度 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。 角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 工厂模式的应用场景： 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌 JAVA实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package FactoryMethod;public class AbstractFactoryTest { public static void main(String[] args) { try { Product a; AbstractFactory af; af = (AbstractFactory) ReadXML1.getObject(); a = af.newProduct(); a.show(); } catch (Exception e) { System.out.println(e.getMessage()); } }}//抽象产品：提供了产品的接口interface Product { public void show();}//具体产品1：实现抽象产品中的抽象方法class ConcreteProduct1 implements Product { public void show() { System.out.println(&quot;具体产品1显示...&quot;); }}//具体产品2：实现抽象产品中的抽象方法class ConcreteProduct2 implements Product { public void show() { System.out.println(&quot;具体产品2显示...&quot;); }}//抽象工厂：提供了厂品的生成方法interface AbstractFactory { public Product newProduct();}//具体工厂1：实现了厂品的生成方法class ConcreteFactory1 implements AbstractFactory { public Product newProduct() { System.out.println(&quot;具体工厂1生成--&gt;具体产品1...&quot;); return new ConcreteProduct1(); }}//具体工厂2：实现了厂品的生成方法class ConcreteFactory2 implements AbstractFactory { public Product newProduct() { System.out.println(&quot;具体工厂2生成--&gt;具体产品2...&quot;); return new ConcreteProduct2(); }} 12345678910111213141516171819202122232425262728package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;class ReadXML1 { //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getObject() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;src/FactoryMethod/config1.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode = nl.item(0).getFirstChild(); String cName = &quot;FactoryMethod.&quot; + classNode.getNodeValue(); //System.out.println(&quot;新类名：&quot;+cName); //通过类名生成实例对象并将其返回 Class&lt;?&gt; c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } }} 《抽象工厂模式Abstract Factory Pattern》 特点： 一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 使用抽象工厂模式一般要满足以下条件。 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。 系统一次只可能消费其中某一族产品，即同族的产品一起使用。 优点： 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。 缺点： 类的个数容易过多，增加复杂度 增加了系统的抽象性和理解难度 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。 角色： 抽象工厂中方法个数不同，抽象产品的个数也不同 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 抽象工厂模式的应用场景： 抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 Java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。 抽象工厂模式通常适用于以下场景： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 JAVA实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package FactoryMethod;public class AbstractFactoryTest { public static void main(String[] args) { try { Product a; AbstractFactory af; af = (AbstractFactory) ReadXML1.getObject(); a = af.newProduct(); a.show(); } catch (Exception e) { System.out.println(e.getMessage()); } }}//抽象产品：提供了产品的接口interface Product { public void show();}//具体产品1：实现抽象产品中的抽象方法class ConcreteProduct1 implements Product { public void show() { System.out.println(&quot;具体产品1显示...&quot;); }}//具体产品2：实现抽象产品中的抽象方法class ConcreteProduct2 implements Product { public void show() { System.out.println(&quot;具体产品2显示...&quot;); }}//抽象工厂：提供了厂品的生成方法interface AbstractFactory { public Product newProduct();}//具体工厂1：实现了厂品的生成方法class ConcreteFactory1 implements AbstractFactory { public Product newProduct() { System.out.println(&quot;具体工厂1生成--&gt;具体产品1...&quot;); return new ConcreteProduct1(); }}//具体工厂2：实现了厂品的生成方法class ConcreteFactory2 implements AbstractFactory { public Product newProduct() { System.out.println(&quot;具体工厂2生成--&gt;具体产品2...&quot;); return new ConcreteProduct2(); }} 12345678910111213141516171819202122232425262728package FactoryMethod;import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;class ReadXML1 { //该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getObject() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;src/FactoryMethod/config1.xml&quot;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(&quot;className&quot;); Node classNode = nl.item(0).getFirstChild(); String cName = &quot;FactoryMethod.&quot; + classNode.getNodeValue(); //System.out.println(&quot;新类名：&quot;+cName); //通过类名生成实例对象并将其返回 Class&lt;?&gt; c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } }} 《建造者模式 Bulider》 特点： 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 优点： 封装性好，构建和表示分离。 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 缺点： 产品的组成部分必须相同，这限制了其使用范围。 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 角色： 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 建造者模式的应用场景： 相同的方法，不同的执行顺序，产生不同的结果。 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。 JAVA实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package pers.lxl.mylearnproject.programbase.designpatterns.creationalpattern.bulider;/**产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。*/class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } public void setPartC(String partC) { this.partC = partC; } public void show() { System.out.println(partA+' '+partB+' '+partC); }}/**抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。*/abstract class Builder { //创建产品对象 protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); //返回产品对象 public Product getResult() { return product; }}/**具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。*/class ConcreteBuilder1 extends Builder { @Override public void buildPartA() { product.setPartA(&quot;建造 PartA&quot;); } @Override public void buildPartB() { product.setPartB(&quot;建造 PartB&quot;); } @Override public void buildPartC() { product.setPartC(&quot;建造 PartC&quot;); }}/**指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。*/class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } //产品构建与组装方法 public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); }}public class ConcreteBuilder { public static void main(String[] args) { Builder builder = new ConcreteBuilder1(); Director director = new Director(builder); Product product = director.construct(); product.show(); }} 结构型模式 《代理模式 Proxy 》 特点： 中介 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 优点： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性 缺点：(动态代理方式解决) 代理模式会造成系统设计中类的数量增加 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 角色： 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 根据代理的创建时期，代理模式分为静态代理和动态代理。 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。 动态：在程序运行时，运用反射机制动态创建而成 代理模式的应用场景： 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。 JAVA实现： 1234567891011121314151617181920212223242526272829303132333435package proxy;public class ProxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.Request(); }}//抽象主题interface Subject { void Request();}//真实主题class RealSubject implements Subject { public void Request() { System.out.println(&quot;访问真实主题方法...&quot;); }}//代理class Proxy implements Subject { private RealSubject realSubject; public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } preRequest(); realSubject.Request(); postRequest(); } public void preRequest() { System.out.println(&quot;访问真实主题之前的预处理。&quot;); } public void postRequest() { System.out.println(&quot;访问真实主题之后的后续处理。&quot;); }} 《适配器模式 Adapter 》 特点： 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 优点： 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。 缺点： 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。 角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 适配器模式的应用场景： 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 JAVA实现： 对象适配器 1234567891011121314151617181920212223242526package pers.lxl.mylearnproject.programbase.designpatterns.structuralpattern.adapter;//对象适配器类class ObjectAdapter implements Target{ private Adaptee adaptee; public ObjectAdapter(Adaptee adaptee) { this.adaptee=adaptee; } @Override public void request() { adaptee.specificRequest(); }}//客户端代码public class objectAdapterPattern{ public static void main(String[] args) { System.out.println(&quot;对象适配器模式测试：&quot;); Adaptee adaptee = new Adaptee(); Target target = new ObjectAdapter(adaptee); target.request(); }} 类适配器 1234567891011121314151617181920212223242526272829303132333435package pers.lxl.mylearnproject.programbase.designpatterns.structuralpattern.adapter;//目标接口interface Target{ public void request();}//适配者接口class Adaptee{ public void specificRequest() { System.out.println(&quot;适配者中的业务代码被调用！&quot;); }}//类适配器类 extends Adaptee implements Targetclass ClassAdapter extends Adaptee implements Target{ @Override public void request() { specificRequest(); }}//客户端代码public class ClassAdapterPattern{ public static void main(String[] args) { System.out.println(&quot;类适配器模式测试：&quot;); Target target = new ClassAdapter(); target.request(); }} 适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图所示。 《桥接模式 Bridge》 特点： 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 优点： 抽象与实现分离，扩展能力强 符合开闭原则 符合合成复用原则 其实现细节对客户透明 缺点： 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。 角色： 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。 桥接模式的应用场景： 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。 JAVA实现： 123456789101112131415161718192021222324252627282930313233343536package bridge;public class BridgeTest { public static void main(String[] args) { Implementor imple = new ConcreteImplementorA(); Abstraction abs = new RefinedAbstraction(imple); abs.Operation(); }}//实现化角色interface Implementor { public void OperationImpl();}//具体实现化角色class ConcreteImplementorA implements Implementor { public void OperationImpl() { System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot;); }}//抽象化角色abstract class Abstraction { protected Implementor imple; protected Abstraction(Implementor imple) { this.imple = imple; } public abstract void Operation();}//扩展抽象化角色class RefinedAbstraction extends Abstraction { protected RefinedAbstraction(Implementor imple) { super(imple); } public void Operation() { System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;); imple.OperationImpl(); }}","link":"/2021/03/01/Draft/2021/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"BUG","slug":"BUG","link":"/tags/BUG/"},{"name":"文件上传下载","slug":"文件上传下载","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"工具教程","slug":"工具教程","link":"/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"NO GAME NO LIFE","slug":"NO-GAME-NO-LIFE","link":"/tags/NO-GAME-NO-LIFE/"},{"name":"Python学习","slug":"Python学习","link":"/tags/Python%E5%AD%A6%E4%B9%A0/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Software Engineer","slug":"Software-Engineer","link":"/tags/Software-Engineer/"},{"name":"待办","slug":"待办","link":"/tags/%E5%BE%85%E5%8A%9E/"},{"name":"书影音","slug":"书影音","link":"/tags/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"},{"name":"健身外型","slug":"健身外型","link":"/tags/%E5%81%A5%E8%BA%AB%E5%A4%96%E5%9E%8B/"},{"name":"学习方法","slug":"学习方法","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"博客计划","slug":"博客计划","link":"/tags/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"},{"name":"每日算法","slug":"每日算法","link":"/tags/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"name":"快查","slug":"快查","link":"/tags/%E5%BF%AB%E6%9F%A5/"},{"name":"每日英语","slug":"每日英语","link":"/tags/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"},{"name":"每日面题","slug":"每日面题","link":"/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E9%A2%98/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/tags/SpringCloud/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"BUG记录","slug":"BUG记录","link":"/categories/BUG%E8%AE%B0%E5%BD%95/"},{"name":"JAVA应用","slug":"JAVA应用","link":"/categories/JAVA%E5%BA%94%E7%94%A8/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"工具教程","slug":"工具教程","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"BUG","slug":"BUG记录/BUG","link":"/categories/BUG%E8%AE%B0%E5%BD%95/BUG/"},{"name":"游戏人生","slug":"游戏人生","link":"/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"},{"name":"业务技术","slug":"JAVA应用/业务技术","link":"/categories/JAVA%E5%BA%94%E7%94%A8/%E4%B8%9A%E5%8A%A1%E6%8A%80%E6%9C%AF/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MYSQL优化","slug":"数据库/MYSQL优化","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E4%BC%98%E5%8C%96/"},{"name":"程序人生","slug":"程序人生","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"待办","slug":"待办","link":"/categories/%E5%BE%85%E5%8A%9E/"},{"name":"书影音","slug":"书影音","link":"/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"},{"name":"健康","slug":"健康","link":"/categories/%E5%81%A5%E5%BA%B7/"},{"name":"博客搭建","slug":"工具教程/博客搭建","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"NO GAME NO LIFE","slug":"游戏人生/NO-GAME-NO-LIFE","link":"/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/NO-GAME-NO-LIFE/"},{"name":"Python学习","slug":"编程语言/Python学习","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%AD%A6%E4%B9%A0/"},{"name":"Nginx","slug":"中间件/Nginx","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Nginx/"},{"name":"Software Engineer","slug":"程序人生/Software-Engineer","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Software-Engineer/"},{"name":"Everyday-TODO","slug":"待办/Everyday-TODO","link":"/categories/%E5%BE%85%E5%8A%9E/Everyday-TODO/"},{"name":"书影音","slug":"书影音/书影音","link":"/categories/%E4%B9%A6%E5%BD%B1%E9%9F%B3/%E4%B9%A6%E5%BD%B1%E9%9F%B3/"},{"name":"健身外型","slug":"健康/健身外型","link":"/categories/%E5%81%A5%E5%BA%B7/%E5%81%A5%E8%BA%AB%E5%A4%96%E5%9E%8B/"},{"name":"学习方法","slug":"学习方法","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"计划","slug":"计划","link":"/categories/%E8%AE%A1%E5%88%92/"},{"name":"每日任务","slug":"每日任务","link":"/categories/%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1/"},{"name":"如何学习一个新知识","slug":"学习方法/如何学习一个新知识","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9F%A5%E8%AF%86/"},{"name":"编程工具","slug":"编程工具","link":"/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"},{"name":"博客计划","slug":"计划/博客计划","link":"/categories/%E8%AE%A1%E5%88%92/%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法基础","slug":"每日任务/算法基础","link":"/categories/%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"资源篇","slug":"工具教程/资源篇","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E8%B5%84%E6%BA%90%E7%AF%87/"},{"name":"程序基础","slug":"程序基础","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"快查","slug":"编程工具/快查","link":"/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E5%BF%AB%E6%9F%A5/"},{"name":"每日英语","slug":"每日任务/每日英语","link":"/categories/%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"},{"name":"每日面题","slug":"每日任务/每日面题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1/%E6%AF%8F%E6%97%A5%E9%9D%A2%E9%A2%98/"},{"name":"GIS","slug":"前端/GIS","link":"/categories/%E5%89%8D%E7%AB%AF/GIS/"},{"name":"Redis","slug":"程序基础/Redis","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/Redis/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","link":"/categories/Spring/SpringCloud/"},{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"RabbitMQ","slug":"中间件/RabbitMQ","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"},{"name":"计算机网络","slug":"编程基础/计算机网络","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"考证","slug":"考证","link":"/categories/%E8%80%83%E8%AF%81/"},{"name":"信息系统项目管理师","slug":"考证/信息系统项目管理师","link":"/categories/%E8%80%83%E8%AF%81/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"},{"name":"设计模式","slug":"程序基础/设计模式","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}